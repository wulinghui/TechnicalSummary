---
title: ShardingSphere
date: 2022-03-08 15:24:10
permalink: /pages/ddfe57/
categories:
  - java
  - 中间件
tags:
  - 
author: 
  name: wulinghui
  link: https://gitee.com/hellowllh/projects
---
# 介绍

最初叫ShardingJDBC。到现在他包含三个重要的产品ShardingJDBC、ShardingProxy和 ShardingSidecar。

|            | ShardingJDBC | ShardingProxy    |
| ---------- | ------------ | ---------------- |
| 数据库     | 任意         | MySQL/PostgreSQL |
| 连接消耗数 | 高           | 低               |
| 异构语言   | 仅java       | 任意             |
| 性能       | 损耗低       | 损耗略高         |
| 中心化     | 无           | 是               |
| 静态入口   | 无           | 有               |
| 业务侵入   | 大           | 无               |



# ShardingJDBC

## 读写分离

核心配置mast name，slave name就行了。

## 核心概念

- 逻辑表：水平拆分的数据库的相同逻辑和数据结构表的总称
- 真实表：在分片的数据库中真实存在的物理表。 
- 数据节点：数据分片的最小单元。由数据源名称和数据表组成 
- 绑定表：分片规则一致的主表和子表。  防止笛卡尔集，提高性能。绑定关系不能自定义，按分片的计算结果绑定的。
- 广播表：也叫公共表，指素有的分片数据源中都存在的表，表结构和表中的数据 在每个数据库中都完全一致(强一致性的)。例如字典表。
- 分片键：用于分片的数据库字段，是将数据库(表)进行水平拆分的关键字段。 SQL中若没有分片字段，将会执行全路由，性能会很差。 
- 分片算法：通过分片算法将数据进行分片，支持通过=、BETWEEN和IN分片。 分片算法需要由应用开发者自行实现，可实现的灵活度非常高。 
- 分片策略：真正用于进行分片操作的是分片键+分片算法。分库和分表策略可以随意组合。

## 配置

- 配置真实数据源
- 指定表的分布情况
- 指定表的主键生成策略
- 选定计算的字段
- 根据计算的字段算出对应的库名。
- 根据计算的字段算出对应的表名。

## 分片算法

### NoneShardingStrategy 

不分片

### InlineShardingStrategy 

- 内联分片
- 按照分片表达式来进行分片。 
- 支持 = 或者 IN 
- 不支持范围分片

### StandardShardingStrategy 

- 标准分片，精确和范围。
- 自定义实现类实现算法
- 支持 = 或者 IN  范围，其中精确分片算法是必须提供的，而范围分片算法则是可选的。
- 只支持单分片键的标准分片策略

### ComplexShardingStrategy

- 复杂分片，多字段分表
- 有标准分片的特性，同时提供按照多个分片列进行综合分片的算法
- 但是分片的类型要保持一致

### HintShardingStrategy

- 强制路由分片
- 强制走业务代码算法中设置的表。比如在按userid奇偶分片的策略下，select userid from t_user where userid in (1,3,5,7,9)可以操作的。
- 分片键是线程隔离的，只在当前线程有效，所以通常建 议使用之后立即关闭，或者用try资源方式打开。
- 限制: 不支持函数计算，不支持多层子查询，不支持UNION



## 主键生成策略

默认提供了UUID和SNOWFLAKE

### UUID

采用UUID.randomUUID()的方式产生唯一且不重复的分布式主键。最终生成一 个字符串类型的主键。缺点是生成的主键无序。

### SNOWFLAKE

- 雪花算法,能够保证不同进程主键的不重复性，**相同进程**主键的有序性。
- 缺点：强依赖机器时钟，如果机器上时钟回拨，会导致发号重复。
- 注意: 他是局部有序，不是全局有序。

- 二进制形式 包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位 以及12bit序列号位。

### SPI扩展

- 目标： 1、全局唯一，2、高性能，3、高可用，4、趋势递增

- 通过SPI实现对应接口实现
- 不要再应用层给他设置主键，**切记**。
- 可以采用时间+redis分布式主键获得区段自增，以实现扩容时不需要进行数据迁移。



## SQL使用限制







# 分片内核剖析

## 解析引擎

词法解析器用于将SQL拆解成抽象语法树，一开始采用Druid再自研再用ANLTR再增加一些AST的缓存机制(针对ANLTR4的特性，官网**建议尽量**采用PreparedStatement的预编译方式来提高SQL执行的性能)。

## 路由引擎

根据解析上下文匹配数据库和表的分片策略，生成路由路径。

单片路由、多片路由、范围路由、广播路由

## 改写引擎

用户只需要面向逻辑库和逻辑表来写SQL，最终由ShardigSphere的改写引擎将 SQL改写为在真实数据库中可以正确执行的语句。

## 执行引擎

ShardingSphere并不是简单的将改写完的SQL提交到数据库执行。执行引擎的目标是自动化的平衡资源控制和执行效率，目前就是靠下面的模式。

### 内存限制模式

不限制连接数，并发执行，但是查询并发，结果集会使用**流式归并**(这个过程慢n^2)，解决内存溢出，吞吐量高，适合OLAP数据分析场景。

### 连接限制模式

对连接数进行限制，内存不限制，查询查用**串行**，结果集**内存归并**，**效率高**，比较适合小数据量的OLTP事务场景。

## 归并引擎

将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求 客户端，称为结果归并。

### 流式归并

流式归并是指以一条一条数据的方式进行迭代归并，而内存归并是将所有结果集 都查询到内存中，进行统一归并

### 内存归并

读出来都在jvm内存中处理。

### 排序归并

多个库，有多个指针去遍历。





# SPI

具体的见官网的《开发者⼿册》

## 解析

- SQLParserFacade： 配置⽤于 SQL 解析的词法分析器和语法分析器⼊口
- SQLVisitorFacade ： SQL 语法树访问器⼊口
- ShardingSphereRuleBuilder ： ⽤于将⽤⼾配置转化为规则对象

## 内核

- DatabaseType ： ⽀持的数据库类型
- SQLRouter ： ⽤于处理路由结果
- SQLRewriteContextDecorator ： ⽤于处理 SQL 改写结果
- SQLExecutionHook ： SQL 执⾏过程监听器
- ResultProcessEngine ： ⽤于处理结果集

## 数据分⽚

- ShardingAlgorithm ： 分⽚算法
- KeyGenerateAlgorithm ： 分布式主键⽣成算法
- DatabaseSQLEntry ： 获取当前时间的数据库⽅⾔

## 其他功能

- ReplicaLoadBalanceAlgorithm ： 读库负载均衡算法
- EncryptAlgorithm ： 数据加密算法
- ShardingTransactionManager ： 分布式事务管理器



# 分布式事务处理方式

强一致性与最终一致性（柔性事务BASE）

## 本地事务

- 不需要修改代码，用spring的@Transactional
- 这也是**默认使用**的事务方式

⽀持项 

- 完全⽀持⾮跨库事务
- 完全⽀持因逻辑异常导致的跨库事务。例如：同⼀事务中，跨两个库更新。更新完毕后，抛出空指 针，则两个库的内容都能回滚。

不⽀持项

- 不⽀持因⽹络、硬件异常导致的跨库事务。例如：同⼀事务中，跨两个库更新，更新完毕后、未提 交之前，第⼀个库宕机，则只有第⼆个库数据提交。
- 不支持跨节点和服务的，比如feign调用了其他的微服务。

## XA 两阶段事务

- 需要引入相关依赖和配置
- ShardingSphere默认采用atomikos作为实现框架实现JTA规范用于XA规范。
- 同时，也支持bitronix、narayana等框架，甚至提供了SPI扩展点

⽀持项

- ⽀持数据分⽚后的跨库事务。
- 两阶段提交保证操作的原⼦性和数据的强⼀致性。
- 服务宕机重启后，提交/回滚中的事务可⾃动恢复。
- ⽀持同时使⽤ XA 和⾮ XA 的连接池。

不⽀持项

- 服务宕机后，在其它机器上恢复提交/回滚中的数据。

## Seata 柔性事务

- 其实也是更多的基于Seata的AT模式（柔性事务BASE）
- 也有SPI接口

⽀持项

- ⽀持数据分⽚后的跨库事务
- ⽀持 RC 隔离级别
- 通过 undo 快照进⾏事务回滚
- ⽀持服务宕机后的，⾃动恢复提交中的事务。

不⽀持项

- 不⽀持除 RC 之外的隔离级别。



# ShardingProxy

ShardingProxy的功能同样是分库分表，但是他是一个独立部署的服务端，提供统一的数据库代理服务。

注意，ShardingProxy目前只支持MySQL和 PostgreSQL。





# 测试影子库

- 进⾏压测数据隔离的影⼦数据库，与⽣产数据库应当使⽤相同的配置。
- 再生产库中，创建平级的影子库，避免环境和主机的问题。
- 可以采用Sharding的影子库功能，多添加一个列，用于标识走对应的影子库。





# 项目使用核心步骤

1. 定义分库分表数据源，再启动类排除默认spring的数据源。
2. 设置默认不分表的数据源
3. 定制分库分表规则
4. 分库分表规则优化： 分库分表规则、绑定表、读写分离、自定义路由策略、自定义主键生成策略等



# 旧数据处理方式

在业务过程中做分库分表，必然要做数据迁移。下面是比较稳妥的方案

1. 要评估数据分片方案，对关键的SQL进行整理并分析
2. 将不支持的sql改成其他方式实现
3. 制定好了分库分表方案，包括主键/分片/路由等等。
4. 不要着急实践，最好是在业务中对SQL进行数据双写（老数据库也写一份）。也可以用SPI的扩展点去做。
5. 这上面的过程中，再去分析方案是不是合适，那些需要调整的，都合适了之后，就可以进行**旧数据迁移**了。可以采用ShardingProxy、keetle等工具去做这些操作。
6. 然后把双写去掉。

# 总结

## 使用

- 分片算法

- 自定义主键生成，等等相关的SPI

  > 比如大尺度上按范围分片，但是在每个数据范围内，使用取模分片。
  >
  > 这样利于扩展又够均匀。
  >
  > 这个还要配合分片策略来做具体的分片，比如要采用Standard中的precise精确分片方式。

- 注意用绑定表减少笛卡尔集

- 注意: 他原生的默认分布式事务，只支持配置的多表和对应的操作，不支持块节点/服务，但是他支持SeataAT。

- 设置默认数据源；达到针对配置的表走分库分表策略，其他的没有配置的表还是会走对应的默认数据库。

## 部署

- 用混合模式部署，运维使用ShardingProxy，开发使用ShardingJDBC，用zk做统一配置。
- 可以用MHA、nginx保证ShardingProxy高可用。

## 原理

- 通过datasource 整合其他框架。
- 连接限制模式，内存限制模式
- 流式归并，内存归并，排序归并





# 思考

- 如何将记录平均分配到两个库的四个表？ 
- 为什么要配置绑定表？  减少笛卡尔集





# 参考资料

[常用MAVEN打包方式总结](https://blog.csdn.net/roykingw/article/details/71486825)

