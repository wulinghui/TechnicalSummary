---
title: Sentinel使用
date: 2022-02-20 18:53:13
permalink: /pages/8ba665/
categories:
  - java
  - 微服务
  - alibaba
tags:
  - 
author: 
  name: wulinghui
  link: https://gitee.com/hellowllh/projects
---


# 简介

## 

## 和Hystrix对比

总之就是比他更好，且还再更新。



## 功能

- [流量控制](https://github.com/alibaba/Sentinel/wiki/流量控制)
- [集群流控](https://github.com/alibaba/Sentinel/wiki/集群流控)
- [网关流控](https://github.com/alibaba/Sentinel/wiki/网关限流)
- [熔断降级](https://github.com/alibaba/Sentinel/wiki/熔断降级)
- [热点参数限流](https://github.com/alibaba/Sentinel/wiki/热点参数限流)
- [系统自适应限流](https://github.com/alibaba/Sentinel/wiki/系统自适应限流)
- [黑白名单控制](https://github.com/alibaba/Sentinel/wiki/黑白名单控制)
- [实时监控数据](https://github.com/alibaba/Sentinel/wiki/实时监控)
- [动态规则](https://github.com/alibaba/Sentinel/wiki/动态规则扩展)

# 功能插槽

- NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；
- ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；
- StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；
- FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；
- AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；
- DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；
- SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；

# 原生API

## 编码模式

```java
 Entry entry = null;
        try {
            // 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。
            entry = SphU.entry(RESOURCE_NAME);
            // 被保护的业务逻辑
            String str = "hello world";
            log.info("====="+str);
            return str;
        } catch (BlockException e1) {
            // 资源访问阻止，被限流或被降级
            //进行相应的处理操作
            log.info("block!");
        } catch (Exception ex) {
            // 若需要配置降级规则，需要通过这种方式记录业务异常
            Tracer.traceEntry(ex, entry);
        } finally {
            if (entry != null) {
                entry.exit();
            }
        }
```



## 注解代理模式

@SentinelResource



# 控制台介绍

机器发现以及健康情况管理、监控（单机和集群），规则管理和推送的功能。

## 流控规则配置

- **资源名**:  接口的API   
- **针对来源**:  默认是default，当多个微服务都调用这个资源时，可以配置微服务名来对指定的微服务设置阈值
- **阈值类型**: 分为QPS和线程数 假设阈值为10
- **QPS类型**: 只得是每秒访问接口的次数>10就进行限流
- **线程数**: 为接受请求该资源分配的线程数>10就进行限流  

### 限流阈值类型

- 线程数
- QPS



### 流控模式

#### 直接

资源调用达到设置的阈值后直接被流控抛出异常  

#### 关联

当关联的资源达到阈值，对当前的资源流控

当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，read_db 和 write_db 这两个资源分别代表数据库读写，我们可以给 read_db 设置限流规则来达到写优先的目的：设置 strategy 为 RuleConstant.STRATEGY_RELATE 同时设置 refResource 为 write_db。这样当写库操作过于频繁时，读数据的请求会被限流。

#### 链路

根据调用链路入口限流。

Sentinel 允许只根据某个入口的统计信息对资源限流。

当入口的资源达到阈值，对当前的资源流控

### 流控效果

#### 快速失败

方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，通过压测确定了系统的准确水位时。

#### Warm Up

即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。

冷加载因子: codeFactor 默认是3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。

 

#### 匀速排队

会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。

应用场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。



## 降级规则

除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。我们需要对不稳定的**弱依赖服务调用**进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。    

### 熔断策略

#### 慢调用比例

选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。

#### 异常比例

当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。

#### 异常数

当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。

## 热点参数限流

热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。

热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。

### 场景

- 商品 ID为5的，是火爆商品，限流，其他的商品都不限流

### 注意：

1. 热点规则需要使用@SentinelResource("resourceName")注解，否则不生效
2. 参数必须是7种基本数据类型才会生效

## 系统规则

自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。

### Load 自适应

系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护

### CPU usage

当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。

### 平均 RT

当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。

### 并发线程数

当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。

### 入口 QPS

当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。

## 授权控制规则

我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制（黑白名单控制）的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。

## 集群规则

假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。

### 集群总体模式

即限制整个集群内的某个资源的总体 qps 不超过此阈值。

### 单机均摊模式

单机均摊模式下配置的阈值等同于单机能够承受的限额，token server 会根据连接数来计算总的阈值（比如独立模式下有 3 个 client 连接到了 token server，然后配的单机均摊阈值为 10，则计算出的集群总量就为 30），按照计算出的总的阈值来进行限制。这种方式根据当前的连接数实时计算总的阈值，**对于机器经常进行变更的环境非常适合。**

# [BlockException异常统一处理](http://t.zoukankan.com/huqi96-p-13629037.html)

自定义BlockExceptionHandler 的实现类统一处理BlockException





# spring组件整合Sentinel

## RestTemplate整合Sentinel  

构造 RestTemplate bean的时候需要加上@SentinelRestTemplate 注解

## OpenFeign整合Sentinel 

feign.sentinel.enabled=true

## [Dubbo整合Sentinel](https://www.jianshu.com/p/480b098aa0d1) 



# [规则的推送](https://www.cnblogs.com/linjiqin/p/15375388.html)

默认使用原始模式，保存在内存中。

![](https://img2020.cnblogs.com/blog/270324/202110/270324-20211007111343323-38621168.png)

## [Sentinel使用Nacos持久化并动态更新配置](https://blog.csdn.net/h273979586/article/details/115596602)

一开始用网上的一些资料保存到nacos，但是直接在Sentinel Dashboard中修改规则配置，配置中心的配置不会发生变化。

这里是个坑，还找了一段时间的bug。用上面的博客修改源码可以实现，亲测好使的。

# 参考资料

[官方文档](https://github.com/alibaba/Sentinel/wiki)

[Sentinel持久化规则](https://www.jianshu.com/p/af42e188fcf7)

