(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{587:function(t,v,_){"use strict";_.r(v);var a=_(7),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"从一个http请求来看网络分层原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从一个http请求来看网络分层原理"}},[t._v("#")]),t._v(" 从一个HTTP请求来看网络分层原理")]),t._v(" "),v("p",[t._v("一个HTTP超具体的请求的分层解析流程:\n域名从浏览器解析域名获得ip，\nhost解析域名获得ip,\nDNS 请求报文  ->  传输层 UDP  （添加UDP报文） ->\nARP （加上IP报文） -> 以太网（加上自己的MAC地址，加上下个地址的MAC）\n-> 物理层 ()   ====> 发到  路由器(3层协议)   【物理层->数据链路层->网络层】\n->   xxxx的递归循环 -> DNS响应报文 原路返回 ->  这里就获得IP了")]),t._v(" "),v("p",[t._v("http (封装http的消息头) -> TCP五层模型 -> 服务器 -> 响应返回 (同上)")]),t._v(" "),v("p",[t._v("#HTTP协议\n超文本传输协议(HyperText Transfer Protocol，HTTP)\n传输  交给TCP")]),t._v(" "),v("p",[t._v("可扩展的语义 -> 消息头扩展\n自描述消息格式 ->  mp3,mp3,json....\n基于网络的超文本信息系统灵活的互动  ->  html 动画")]),t._v(" "),v("p",[t._v("请求行报文格式  === 起始行")]),t._v(" "),v("p",[t._v("HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，\n一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，\n服务器因此可以获得一些信息用于处理。 防盗链的使用")]),t._v(" "),v("p",[t._v("Server : nginx , Apache\nDate 在请求头和响应头都有。")]),t._v(" "),v("p",[t._v("3.HTTP请求的完整过程")]),t._v(" "),v("p",[t._v("tcp3次，组装http报文，")]),t._v(" "),v("p",[t._v("浏览器收到响应之后， 根据不同的格式做不同的事。\n如果是下载的话就会下载。\n如果是html的话， 就会开始渲染页面，再去请求html里面的内容.递归.")]),t._v(" "),v("h1",{attrs:{id:"tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),v("p",[t._v("双向全双工，客户端和服务端都可以关闭。")]),t._v(" "),v("p",[t._v("tcp  加上协议头，5元组。\n报文标识，ACK、SYN、FIN等等。\nReceive window 可接受。")]),t._v(" "),v("p",[t._v("源端口一般随机生成。")]),t._v(" "),v("p",[t._v("linux抓包:\ntcpdump -i 网卡name")]),t._v(" "),v("p",[t._v("windows，发送报文\nnc")]),t._v(" "),v("p",[t._v("内核，一个监听端口，维护一个SYN队列。\n收到ACK才出队。")]),t._v(" "),v("p",[t._v("查看tcp连接\nnetstat -tpn -c 1")]),t._v(" "),v("p",[t._v("连接关闭变成TIME_WAIT")]),t._v(" "),v("p",[t._v("第一次挥手，FIN 1  客户端不可写。")]),t._v(" "),v("p",[t._v("TIME_WAIT还要为什么等待2MSL（一个报文来回时间）?\nMSL 最大报文生成时间\n防止滞留在网络中的报文，对新建立的连接造成数据扰乱，比如服务器中其他的报文还没发完，")]),t._v(" "),v("p",[t._v("MSS 是最大的，实际不超过他，会变动。\nTCP不限制数据大小。")]),t._v(" "),v("p",[t._v("TCP\n报文里面有seqNum 保证有序，去重，要保证完整性。")]),t._v(" "),v("p",[t._v("滑动窗口大小同通过 tcp三次握手和对端协商，且受网络状况影响\n==  滑动窗口大小 和 tcp三次握手、网络状况、B端决定。")]),t._v(" "),v("p",[t._v("新的算法，选择性ack等等.. 有好多升级版的算法。")]),t._v(" "),v("h1",{attrs:{id:"https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" https")]),t._v(" "),v("p",[t._v("验证证书是为了防止DNS解析被篡改成其他非法的服务器，具体验证是层层验证CA机构，一直到根机构(由操作系统或浏览器提供)都确认无误。\n(接头身份，层层确认。)\n下面就只要安心的保证，内容是加密且双方仅有2人知道。"),v("br"),t._v("\n具体是，非对称算法，最高机密级别保证密钥是不被人知道的。 (谍战密码本.)\n再通过这个不被人知道的密钥，进行简单高效的对称加密。        (通过密码本交流.)")]),t._v(" "),v("p",[t._v("https://blog.csdn.net/weixin_30785593/article/details/96220957")]),t._v(" "),v("p",[t._v("https://blog.csdn.net/latico/article/details/102800197")]),t._v(" "),v("h3",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),v("p",[t._v("bitMap原理??  一次性创建一个大的数组吗???\n为什么不推荐用UUID为主键??? 排序吗??\n市面上的服务注册和发现有哪些??    最重要的是什么??   什么是一致性?? 怎么保证一致性??  什么是熔断,用途??\nredis 集群下如何保证原子性??\nCAS是什么??\nSpring怎么保证事务?")]),t._v(" "),v("h3",{attrs:{id:"-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[t._v("#")])]),t._v(" "),v("ol",[v("li",[t._v("总结，项目的总结。或者说一下亮点，    IM消息的重复，有序性，不丢失。")]),t._v(" "),v("li",[t._v("基础解题的思路得有。")]),t._v(" "),v("li",[t._v("要说项目的亮点。")]),t._v(" "),v("li",[t._v("不要说流水账，要简洁，说重点，不要带我觉得等等自我否定的语气。")])]),t._v(" "),v("h1",{attrs:{id:"商业工厂级别的强有序性的保证实现-参考tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#商业工厂级别的强有序性的保证实现-参考tcp"}},[t._v("#")]),t._v(" 商业工厂级别的强有序性的保证实现，参考TCP:")]),t._v(" "),v("p",[t._v("通知发送端方式2种，发消息时接口的返回，推送。")]),t._v(" "),v("p",[t._v("客户端有序列号 和 下个序列号 来保证强顺序性  ，和标识保证系统和消息状况。")]),t._v(" "),v("p",[t._v("但出现网络或者系统压力问题，客户端会触发，滑动时间窗口。 这个方案前端不接受。\n那就后端实现，通知发送端，消息发送慢一点，或者发送阻塞消息。")]),t._v(" "),v("p",[t._v("那就后端实现，服务端要确保收到客户端的ack后，才发送下一条消息。\n如果这里在服务端没有找到下一条消息，通知发送端，去做丢失消息的重发。")]),t._v(" "),v("p",[t._v("IM系统里面还有报警，通知。")]),t._v(" "),v("p",[t._v("https://blog.csdn.net/aa1928992772/article/details/85240358")]),t._v(" "),v("h1",{attrs:{id:"tcp分层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp分层"}},[t._v("#")]),t._v(" TCP分层")]),t._v(" "),v("p",[t._v("回来的时候会逐级去掉mac,ip,tcp报文头。")]),t._v(" "),v("h1",{attrs:{id:"工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工具"}},[t._v("#")]),t._v(" 工具")]),t._v(" "),v("h2",{attrs:{id:"telnet"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#telnet"}},[t._v("#")]),t._v(" telnet")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("telnet 的⼀个最⼤作⽤就是检查⼀个端⼝是否处于打开，使⽤的命令是 telnet [domainname or ip] [port]，这条命令能告诉我们到远端 server 指定端⼝的⽹连接是否可达。")])]),t._v(" "),v("li",[v("p",[t._v("可以用于发送请求")])])]),t._v(" "),v("h2",{attrs:{id:"netstat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netstat"}},[t._v("#")]),t._v(" netstat")]),t._v(" "),v("ul",[v("li",[t._v("-a (all)显示所有选项，默认不显示LISTEN相关")]),t._v(" "),v("li",[t._v("-t (tcp)仅显示tcp相关选项")]),t._v(" "),v("li",[t._v("-u (udp)仅显示udp相关选项")]),t._v(" "),v("li",[t._v("-n 拒绝显示别名，能显示数字的全部转化成数字。")]),t._v(" "),v("li",[t._v("-l 仅列出有在 Listen (监听) 的服務状态")]),t._v(" "),v("li",[t._v("-p 显示建⽴相关链接的程序名")]),t._v(" "),v("li",[t._v("-r 显示路由信息，路由表")]),t._v(" "),v("li",[t._v("-e 显示扩展信息，例如uid等")]),t._v(" "),v("li",[t._v("-s 按各个协议进⾏统计")]),t._v(" "),v("li",[t._v("-c 每隔⼀个固定时间，执⾏该netstat命令")])]),t._v(" "),v("h2",{attrs:{id:"tcpdump"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcpdump"}},[t._v("#")]),t._v(" tcpdump")]),t._v(" "),v("p",[t._v("⼀个命令⾏的⽹络流量分析⼯具，功能⾮常强⼤,⼀般我们⽤来抓TCP的包。")]),t._v(" "),v("div",{staticClass:"language-bash line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[t._v("tcpdump "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-i")]),t._v(" any\ntcpdump "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-i")]),t._v(" any "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("host")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1\n\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("h2",{attrs:{id:"wireshark"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#wireshark"}},[t._v("#")]),t._v(" wireshark")]),t._v(" "),v("p",[t._v("tcpdump，它是命令⾏程序，对 linux 服务器⽐较友好，简单快速适合简单的⽂本协议的分析和处理。")]),t._v(" "),v("p",[t._v("wireshark 有图形化的界⾯，在windows中使用，分析功能⾮常强⼤，不仅仅是⼀个抓包⼯具，且⽀持众多的协议。")]),t._v(" "),v("p",[t._v("wireshark可以演示下⽹络分层")]),t._v(" "),v("h1",{attrs:{id:"思考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[t._v("#")]),t._v(" 思考")]),t._v(" "),v("h2",{attrs:{id:"tcp-为什么不会2次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-为什么不会2次握手"}},[t._v("#")]),t._v(" TCP 为什么不会2次握手")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("比如"),v("strong",[t._v("最后一次")]),t._v("，客户端没有最后的ACK，那么只能保证服务端，客户端是保证不了连接上的。\n那么这样子就会导致服务端存在好多无效的连接，资源就浪费了。")])]),t._v(" "),v("li",[v("p",[t._v("如果是第二次，那么客户端就是一厢情愿了，可能对应的服务端都不存在。")])])]),t._v(" "),v("h2",{attrs:{id:"四次挥手后为什么还要等待-2msl后释放连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手后为什么还要等待-2msl后释放连接"}},[t._v("#")]),t._v(" 四次挥手后为什么还要等待 2MSL后释放连接")]),t._v(" "),v("ul",[v("li",[t._v("防止客户端的最后一次的ACK报文丢失，导致B重复发送FIN。")]),t._v(" "),v("li",[t._v("防止滞留在网络中的报文（这些报文服务端是已经处理的了），对新建立的连接造成数据扰乱")])]),t._v(" "),v("h2",{attrs:{id:"tcp的四次挥手为什么是四次-为什么不能是三次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp的四次挥手为什么是四次-为什么不能是三次"}},[t._v("#")]),t._v(" TCP的四次挥手为什么是四次？为什么不能是三次？")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("把最后一次去掉就是上面等待 2MSL的原因了，客户端不需要ACK确认，可能B发的FN丢失，客户端就一直等着连接。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("把第2次去掉")]),t._v("，第2/3合成一次，第2次是立刻发ack，进入close_wait状态，处理一些服务端存在的数据，这时间可以很长。")])])]),t._v(" "),v("p",[t._v("那么以LAST_ACK时刻发送的话，客户端可能已经等了几分钟了，这时客户端就会重发。")]),t._v(" "),v("ul",[v("li",[t._v("如果把第3次去掉，那么还在服务端的还未发送的数据就丢失了。")])]),t._v(" "),v("h2",{attrs:{id:"tcp-为什么不会4次握手和5次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-为什么不会4次握手和5次挥手"}},[t._v("#")]),t._v(" TCP 为什么不会4次握手和5次挥手")]),t._v(" "),v("p",[t._v("3次握手就能保证双方建立连接了，再多一次，就浪费了。")]),t._v(" "),v("p",[t._v("挥手同理。")]),t._v(" "),v("h2",{attrs:{id:"为什么-synfin-不包含数据却要消耗一个序列号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么-synfin-不包含数据却要消耗一个序列号"}},[t._v("#")]),t._v(" 为什么 SYNFIN 不包含数据却要消耗一个序列号")]),t._v(" "),v("p",[t._v("凡是需要对端确认的，⼀定消耗TCP报⽂的序列号。")]),t._v(" "),v("p",[t._v("序列号，用来保证去重、有序。")]),t._v(" "),v("p",[t._v("SYN 和FIN需要对端的确认,所以需要消耗⼀个序列号。")]),t._v(" "),v("h2",{attrs:{id:"什么是半连接队列-什么是syn-flood攻击-半开放攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是半连接队列-什么是syn-flood攻击-半开放攻击"}},[t._v("#")]),t._v(" 什么是半连接队列？什么是SYN Flood攻击（半开放攻击）？")]),t._v(" "),v("h2",{attrs:{id:"tcp快速打开-tfo-的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp快速打开-tfo-的原理"}},[t._v("#")]),t._v(" TCP快速打开(TFO)的原理")]),t._v(" "),v("p",[t._v("TCP 快速打开（TCP Fast Open，TFO）")]),t._v(" "),v("p",[t._v("TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第⼀个 SYN 包的时候就开始传数据了， 不过它要求当前客户端之前已经完成过「正常」的三次握⼿。")]),t._v(" "),v("p",[t._v("快速打开分两个阶段：请求 Fast Open Cookie 和 真正开始 TCP Fast Open")]),t._v(" "),v("h3",{attrs:{id:"fast-open-cookie"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fast-open-cookie"}},[t._v("#")]),t._v(" Fast Open Cookie")]),t._v(" "),v("p",[t._v("发送SYN带cookie请求，服务端给ACK+cookie，客户端存cookie，发ACK")]),t._v(" "),v("h3",{attrs:{id:"tcp-fast-open"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-fast-open"}},[t._v("#")]),t._v(" TCP Fast Open")]),t._v(" "),v("p",[t._v("第一次发送SYN+Cookie+数据(http内容...)，服务端校验cookie成功了，就返回SYN+ACK，校验失败就走正常的3次握手。")]),t._v(" "),v("h3",{attrs:{id:"优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[t._v("#")]),t._v(" 优势")]),t._v(" "),v("ul",[v("li",[t._v("利⽤握⼿去除⼀个往返 RTT ，有了cookie以后就SYN+数据一起发了，不需要再握手了。")]),t._v(" "),v("li",[t._v("可以防⽌ SYN-Flood 攻击之类的")])]),t._v(" "),v("h2",{attrs:{id:"tcp报文中的时间戳有什么作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp报文中的时间戳有什么作用"}},[t._v("#")]),t._v(" TCP报文中的时间戳有什么作用？")]),t._v(" "),v("p",[t._v("时间戳放到选型上面，由四部分构成:")]),t._v(" "),v("p",[t._v("类别（kind）、⻓度（Length）、发送⽅时间戳（TS value）、回显时间戳（TS Echo Reply）")]),t._v(" "),v("ul",[v("li",[t._v("计算往返时延 RTT(Round-Trip Time)")]),t._v(" "),v("li",[t._v("防⽌序列号的回绕问题")])]),t._v(" "),v("h2",{attrs:{id:"tcp-的超时重传时间-rto-是如何计算的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的超时重传时间-rto-是如何计算的"}},[t._v("#")]),t._v(" TCP 的超时重传时间（RTO）是如何计算的？")]),t._v(" "),v("p",[t._v("最简单的想法就是取平均值。")]),t._v(" "),v("p",[t._v("经典算法引⼊了「平滑往返时间」（Smoothed round trip time，SRTT）：经过平滑后的RTT的值，每测量⼀次 RTT 就对 SRTT 作⼀次更新计算。")]),t._v(" "),v("p",[t._v("平滑因⼦ α = 0.8")]),t._v(" "),v("p",[t._v("SRTT = 80% 的原始值 + 20% 的新采样RTT值")]),t._v(" "),v("h2",{attrs:{id:"tcp-的流量控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的流量控制"}},[t._v("#")]),t._v(" TCP 的流量控制？")]),t._v(" "),v("p",[t._v("流量控制就是: 通过"),v("strong",[t._v("接收缓存区")]),t._v("的⼤⼩，控制发送端的发送。如果对⽅的接收缓存区满 了，就不能再继续发送了，而是存在"),v("strong",[t._v("发送缓存区")]),t._v("。")]),t._v(" "),v("p",[t._v("也就是再服务端发送的ACK中，会带有一个"),v("strong",[t._v("窗口大小")]),t._v("。客户端利用"),v("strong",[t._v("滑动时间窗口算法")]),t._v("，来控制发送速度。")]),t._v(" "),v("h2",{attrs:{id:"tcp-的keep-alive的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的keep-alive的原理"}},[t._v("#")]),t._v(" TCP 的keep-alive的原理")]),t._v(" "),v("ul",[v("li",[t._v("背景: 假设应⽤程序是⼀个 web 服务器，客户端发出三次握⼿以后故障宕机或被踢掉⽹线，对于 web 服务器 ⽽已，下⼀个数据包将永远⽆法到来，但是它⼀⽆所知。")]),t._v(" "),v("li",[t._v("需求 ：考虑到了这种检测⻓时间死连接的需求，于是乎设计了 keepalive 机制。")]),t._v(" "),v("li",[t._v("它的作⽤ ： 就是探测对端的连接有没有失效")]),t._v(" "),v("li",[t._v("实现:  通过定时发送探测包来探测连接的对端是否存活，不过默认 情况下需要 7200s 没有数据包交互才会发送 keepalive 探测包。")]),t._v(" "),v("li",[t._v("不足: 往往这个时间太久了，我们熟知的很多组件都没有开启 keepalive 特性，⽽是选择在应⽤层做⼼跳机制。")])]),t._v(" "),v("h2",{attrs:{id:"tcp中的端口号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp中的端口号"}},[t._v("#")]),t._v(" TCP中的端⼝号")]),t._v(" "),v("p",[t._v("端⼝号在⽹络分层中TCP的消息头中，分为源端口和目标端口.")]),t._v(" "),v("ul",[v("li",[t._v("系统端口(熟知端⼝号): 范围0~1023")]),t._v(" "),v("li",[t._v("应用端口(已登记的端⼝号)：范围1024~49151")]),t._v(" "),v("li",[t._v("源端口(临时端⼝号)：范围49152～65535")])]),t._v(" "),v("h2",{attrs:{id:"-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[t._v("#")])]),t._v(" "),v("h2",{attrs:{id:"确认号问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#确认号问题"}},[t._v("#")]),t._v(" 确认号问题")]),t._v(" "),v("p",[t._v("A B 两个主机之间建⽴了⼀个 TCP 连接，A 主机发给 B 主机两个 TCP 报⽂，⼤⼩分别是 500 和 300， 第⼀个报⽂的序列号是 200，那么 B 主机接收两个报⽂后，返回的确认号是多少？")]),t._v(" "),v("p",[t._v("一个连接是seq+1")]),t._v(" "),v("p",[t._v("二个是: 2个报文累计 + 第一个序列号 =  500 + 300 + 200")]),t._v(" "),v("h2",{attrs:{id:"ip-数据包解析问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ip-数据包解析问题"}},[t._v("#")]),t._v(" IP 数据包解析问题")]),t._v(" "),v("p",[t._v("收到 IP 数据包解析以后，它怎么知道这个分组应该投递到上层的哪⼀个协议（UDP 或 TCP）？")]),t._v(" "),v("p",[t._v("再IP头信息中，有个协议，该内容为。")]),t._v(" "),v("p",[t._v("协议: 区分IP协议上的上层协议。在Linux系统的/etc/protocols⽂件中定义了所有上层协议对应 的协议字段，ICMP为1，TCP为6，UDP为17")]),t._v(" "),v("h2",{attrs:{id:"粘包和拆包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#粘包和拆包"}},[t._v("#")]),t._v(" "),v("a",{attrs:{href:"https://www.jianshu.com/p/9e3cefc21ca9",target:"_blank",rel:"noopener noreferrer"}},[t._v("粘包和拆包"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("TCP 提供了⼀种字节流服务，⽽收发双⽅都不保持记录的边界，应⽤程序应该如何提供他们⾃⼰的记录 标识呢？")]),t._v(" "),v("p",[t._v('应⽤程序使⽤⾃⼰约定的规则来表示消息的边界，⽐如有⼀些使⽤回⻋+换⾏（"\\r\\n"），⽐如 Redis 的通信协议（RESP protocol）')]),t._v(" "),v("ul",[v("li",[t._v("消息定长，例如每个报文固定200字节，如果不够，空位补空格")]),t._v(" "),v("li",[t._v("在包尾增加回车换行符进行分割，如FTP协议")]),t._v(" "),v("li",[t._v("将消息分为消息头和消息体，消息头中包含消息的长度，字段等信息")]),t._v(" "),v("li",[t._v("更复杂的应用层协议")])]),t._v(" "),v("h2",{attrs:{id:"tcp-和-udp-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp-的区别"}},[t._v("#")]),t._v(" TCP 和 UDP 的区别")]),t._v(" "),v("ul",[v("li",[t._v("TCP是⼀个⾯向连接的、可靠的、基于字节流的传输层协议。")]),t._v(" "),v("li",[t._v("UDP是⼀个⾯向⽆连接的传输层协议")])]),t._v(" "),v("h3",{attrs:{id:"面向连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向连接"}},[t._v("#")]),t._v(" ⾯向连接")]),t._v(" "),v("p",[t._v("⾯向连接。所谓的连接，指的是客户端和服务器的连接，在双⽅互相通信之前，TCP 需要三次握⼿建⽴ 连接，⽽ UDP 没有相应建⽴连接的过程。")]),t._v(" "),v("h3",{attrs:{id:"可靠性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可靠性"}},[t._v("#")]),t._v(" 可靠性")]),t._v(" "),v("p",[t._v("可靠性。TCP 花了⾮常多的功夫保证连接的可靠，这个可靠性体现在哪些⽅⾯呢？")]),t._v(" "),v("ol",[v("li",[t._v("TCP有状态：TCP 会精准记录哪些数据发送了，哪些数据被对⽅接收了，哪些没有被接收到，⽽且保 证数据包按序到达，不允许半点差错")]),t._v(" "),v("li",[t._v("TCP可控制：意识到丢包了或者⽹络环境不佳，TCP 会根据具体情况调整⾃⼰的⾏为，控制⾃⼰的发 送速度或者重发")])]),t._v(" "),v("h1",{attrs:{id:"设计qq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计qq"}},[t._v("#")]),t._v(" 设计QQ")]),t._v(" "),v("p",[t._v("登陆采⽤TCP协议和HTTP协议，你和好友之间发送消息，主要采⽤UDP协议，内⽹传⽂件采⽤ 了P2P技术。")]),t._v(" "),v("p",[t._v("过程:")]),t._v(" "),v("ol",[v("li",[t._v("登陆过程，客户端client 采⽤TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之 后，会有⼀个TCP连接来保持在线状态。")]),t._v(" "),v("li",[t._v("和好友发消息，客户端client采⽤UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息 的可靠，采⽤上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可 重新发送。")]),t._v(" "),v("li",[t._v("如果是在内⽹⾥⾯的两个客户端传⽂件，QQ采⽤的是P2P技术，不需要服务器中转。")])]),t._v(" "),v("h1",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29539671",target:"_blank",rel:"noopener noreferrer"}},[t._v("什么是SYN Flood攻击？"),v("OutboundLink")],1)]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("直接攻击IP地址不被欺骗的SYN Flood被称为直接攻击")]),t._v(" "),v("li",[t._v("欺骗性攻击")]),t._v(" "),v("li",[t._v("分布式攻击（DDoS）")])]),t._v(" "),v("p",[t._v("解决方法:")]),t._v(" "),v("ol",[v("li",[t._v("增加积压队列")]),t._v(" "),v("li",[t._v("回收最早的半开TCP连接")]),t._v(" "),v("li",[t._v("SYN cookie")])])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://dun.163.com/news/p/69294ba2366f49ae9f21d904f661023c",target:"_blank",rel:"noopener noreferrer"}},[t._v("syn_flood攻击原理是什么？如何防范syn_flood攻击？"),v("OutboundLink")],1)]),t._v(" "),v("blockquote",[v("p",[t._v("买好的防火墙服务，"),v("strong",[t._v("cookie源认证")]),t._v("，"),v("strong",[t._v("reset认证")]),t._v("，设置ip的黑名单。")])]),t._v(" "),v("p",[t._v("流量控制（会有客户端未接收数）、超时重传时间计算规则、剔除长久未连接的客户端。")])])}),[],!1,null,null,null);v.default=s.exports}}]);