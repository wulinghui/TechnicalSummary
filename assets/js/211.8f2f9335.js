(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{570:function(a,s,t){"use strict";t.r(s);var r=t(7),e=Object(r.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"rdb快照-snapshot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb快照-snapshot"}},[a._v("#")]),a._v(" RDB快照（snapshot）")]),a._v(" "),s("h2",{attrs:{id:"内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),s("p",[a._v("将内存数据库快照保存在名字为 dump.rdb 的二进制文件中")]),a._v(" "),s("h2",{attrs:{id:"策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#策略"}},[a._v("#")]),a._v(" 策略")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("N 秒内数据集至少有 M 个改动，保存一次")])]),a._v(" "),s("li",[s("p",[a._v("配置:   "),s("code",[a._v("# save 60 1000 //关闭RDB只需要将所有的save保存策略注释掉即可")])])])]),a._v(" "),s("h2",{attrs:{id:"执行命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行命令"}},[a._v("#")]),a._v(" 执行命令")]),a._v(" "),s("p",[s("code",[a._v("save")])]),a._v(" "),s("blockquote",[s("p",[a._v("同步，阻塞redis其它命令，不会消耗额外内存")])]),a._v(" "),s("p",[s("code",[a._v("bgsave")])]),a._v(" "),s("blockquote",[s("p",[a._v("异步，不阻塞redis其它命令，会消耗额外内存")])]),a._v(" "),s("h2",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("恢复数据快，体积小")]),a._v(" "),s("h2",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("p",[a._v("如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失 最近写入、且仍未保存到快照中的那些数据")]),a._v(" "),s("h1",{attrs:{id:"aof-append-only-file"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-append-only-file"}},[a._v("#")]),a._v(" AOF（append-only file）")]),a._v(" "),s("h2",{attrs:{id:"内容-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内容-2"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),s("p",[a._v("将修改的每一条指令记录进文件appendonly.aof中，先写入os cache，每隔一段时间 fsync到磁盘")]),a._v(" "),s("h2",{attrs:{id:"策略-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#策略-2"}},[a._v("#")]),a._v(" 策略")]),a._v(" "),s("p",[a._v("推荐（默认）的措施为每秒 fsync 一次， 这种策略可以兼顾速度和安全性。")]),a._v(" "),s("h3",{attrs:{id:"appendfsync-always"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#appendfsync-always"}},[a._v("#")]),a._v(" appendfsync always")]),a._v(" "),s("p",[a._v("每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。")]),a._v(" "),s("h3",{attrs:{id:"appendfsync-everysec"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#appendfsync-everysec"}},[a._v("#")]),a._v(" appendfsync everysec")]),a._v(" "),s("p",[a._v("每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。")]),a._v(" "),s("h3",{attrs:{id:"appendfsync-no"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#appendfsync-no"}},[a._v("#")]),a._v(" appendfsync no")]),a._v(" "),s("p",[a._v("从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。")]),a._v(" "),s("h3",{attrs:{id:"配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[a._v("#")]),a._v(" 配置")]),a._v(" "),s("p",[s("code",[a._v("# appendonly yes")])]),a._v(" "),s("h2",{attrs:{id:"aof重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof重写"}},[a._v("#")]),a._v(" AOF重写")]),a._v(" "),s("p",[a._v("AOF文件里可能有太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件")]),a._v(" "),s("h3",{attrs:{id:"手动重写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手动重写"}},[a._v("#")]),a._v(" 手动重写")]),a._v(" "),s("p",[s("code",[a._v("bgrewriteaof")])]),a._v(" "),s("h3",{attrs:{id:"配置-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置-2"}},[a._v("#")]),a._v(" 配置")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# auto‐aof‐rewrite‐min‐size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就 很快，重写的意义不大 ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# auto‐aof‐rewrite‐percentage 100 //aof文件自上一次重写后文件大小增长了100%则再次触发重写")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h2",{attrs:{id:"优点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("数据更全，数据不容易丢失")]),a._v(" "),s("h2",{attrs:{id:"缺点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("p",[a._v("恢复数据慢，体积大")]),a._v(" "),s("h1",{attrs:{id:"混合模式-4-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合模式-4-0"}},[a._v("#")]),a._v(" 混合模式(4.0)")]),a._v(" "),s("h2",{attrs:{id:"内容-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内容-3"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),s("p",[a._v("AOF在重写时，先把内存做RDB快照处理，之后生成的命令是aof。")]),a._v(" "),s("h2",{attrs:{id:"配置-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置-3"}},[a._v("#")]),a._v(" 配置")]),a._v(" "),s("ul",[s("li",[a._v("必须先开启aof")]),a._v(" "),s("li",[a._v("# aof‐use‐rdb‐preamble yes")])]),a._v(" "),s("h2",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。")]),a._v(" "),s("h1",{attrs:{id:"运维备份策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运维备份策略"}},[a._v("#")]),a._v(" 运维备份策略")]),a._v(" "),s("ul",[s("li",[a._v("crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去")]),a._v(" "),s("li",[a._v("每天都保留一份当日的数据备份到一个目录中去可以保留最近1个月的备份")]),a._v(" "),s("li",[a._v("每次copy备份的时候，都把太旧的备份给删了")]),a._v(" "),s("li",[a._v("每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏")])]),a._v(" "),s("h1",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/sumengnan/article/details/113095458",target:"_blank",rel:"noopener noreferrer"}},[a._v("redis三种持久化方式"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);