(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{564:function(t,r,e){"use strict";e.r(r);var s=e(7),a=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"order-by优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#order-by优化"}},[t._v("#")]),t._v(" Order by优化")]),t._v(" "),r("h2",{attrs:{id:"排序方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#排序方式"}},[t._v("#")]),t._v(" 排序方式")]),t._v(" "),r("p",[t._v("MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。")]),t._v(" "),r("h3",{attrs:{id:"index"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#index"}},[t._v("#")]),t._v(" index")]),t._v(" "),r("p",[t._v("order by的条件不在索引列上，就会产生Using filesort")]),t._v(" "),r("h3",{attrs:{id:"filesort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#filesort"}},[t._v("#")]),t._v(" filesort")]),t._v(" "),r("p",[t._v("字段的总长度小于max_length_for_sort_data ， 则使用单路排序模式")]),t._v(" "),r("h4",{attrs:{id:"单路排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单路排序"}},[t._v("#")]),t._v(" 单路排序")]),t._v(" "),r("p",[t._v("是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序")]),t._v(" "),r("h4",{attrs:{id:"双路排序-回表排序模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双路排序-回表排序模式"}},[t._v("#")]),t._v(" 双路排序（回表排序模式）")]),t._v(" "),r("p",[t._v("是首先根据相应的条件取出相应的排序字段和可以直接定位行 数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段")]),t._v(" "),r("h2",{attrs:{id:"联和索引排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#联和索引排序"}},[t._v("#")]),t._v(" 联和索引排序")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("explain查询的Extra字段里尽量不要出现using filesort")])]),t._v(" "),r("li",[r("p",[t._v("尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则")])]),t._v(" "),r("li",[r("p",[t._v("order by默认升序，索引的排序方式默认也是升序。 desc变成了降序了，顺序不一样，可以采用（降序索引）；")])]),t._v(" "),r("li",[r("p",[t._v("对于排序来说，多个相等条件也是范围查询，导致filesort 。")])]),t._v(" "),r("li",[r("p",[t._v("order by满足两种情况会使用Using index。")]),t._v(" "),r("ol",[r("li",[t._v("order by语句使用索引最左前列。")]),t._v(" "),r("li",[t._v("使用where子句与order by子句条件列组合满足索引最左前列。与索引的排序方式不同，则会产生filesort")])])]),t._v(" "),r("li",[r("p",[t._v("如果order by的条件不在索引列上，就会产生Using filesort。")])]),t._v(" "),r("li",[r("p",[t._v("能用覆盖索引尽量用覆盖索引。")])])]),t._v(" "),r("h1",{attrs:{id:"group-by优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#group-by优化"}},[t._v("#")]),t._v(" group by优化")]),t._v(" "),r("ol",[r("li",[t._v("group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。")]),t._v(" "),r("li",[t._v("对于group by的优化如果不需要排序的可以加上"),r("strong",[t._v("order by null禁止排序")]),t._v("。")]),t._v(" "),r("li",[t._v("where高于having，能写在where中的限定条件就不要去having限定了。")])]),t._v(" "),r("h1",{attrs:{id:"limit-优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#limit-优化"}},[t._v("#")]),t._v(" limit 优化")]),t._v(" "),r("h2",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),r("p",[t._v("limit 10000,10;")]),t._v(" "),r("p",[t._v("看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。")]),t._v(" "),r("h2",{attrs:{id:"常见分页优化技巧"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见分页优化技巧"}},[t._v("#")]),t._v(" 常见分页优化技巧")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("根据自增且连续的主键排序的分页查询")]),t._v(" "),r("p",[r("code",[t._v("select * from employees where id > 10000 limit 5;")])])]),t._v(" "),r("li",[r("p",[t._v("根据非主键字段排序的分页查询\n"),r("strong",[t._v("让排序时返回的字段尽可能少")])])])]),t._v(" "),r("p",[r("code",[t._v("select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;")])]),t._v(" "),r("h1",{attrs:{id:"join关联查询优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#join关联查询优化"}},[t._v("#")]),t._v(" Join关联查询优化")]),t._v(" "),r("ul",[r("li",[t._v("关联字段加索引")]),t._v(" "),r("li",[t._v("小表驱动大表，当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表时驱动表，左表是被驱动表，当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。")]),t._v(" "),r("li",[t._v("如果有索引一般选择 NLJ 算法，有索引的情况下 NLJ 算法比 BNL算法性能更高")])]),t._v(" "),r("h2",{attrs:{id:"嵌套循环连接-nlp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#嵌套循环连接-nlp"}},[t._v("#")]),t._v(" 嵌套循环连接(NLP)")]),t._v(" "),r("ul",[r("li",[t._v("没有内存机制")]),t._v(" "),r("li",[t._v("Extra 中未出现 Using join buffer 则表示使用的 join 算 法是 NLJ")])]),t._v(" "),r("h2",{attrs:{id:"基于块的嵌套循环连接-bnl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于块的嵌套循环连接-bnl"}},[t._v("#")]),t._v(" 基于块的嵌套循环连接(BNL)")]),t._v(" "),r("ul",[r("li",[t._v("join_buffer (把一部分数据读到内存)")]),t._v(" "),r("li",[t._v("被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法")])]),t._v(" "),r("h1",{attrs:{id:"in和exsits优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#in和exsits优化"}},[t._v("#")]),t._v(" in和exsits优化")]),t._v(" "),r("ul",[r("li",[t._v("小表驱动大表")]),t._v(" "),r("li",[t._v("先执行in内部的查询")]),t._v(" "),r("li",[t._v("后执行exsits内部的查询")])]),t._v(" "),r("h1",{attrs:{id:"count查询优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#count查询优化"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://blog.csdn.net/iFuMI/article/details/77920767",target:"_blank",rel:"noopener noreferrer"}},[t._v("count查询优化"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("strong",[t._v("count(*)≈count(1)>count(字段)>count(主键 id)")])]),t._v(" "),r("ul",[r("li",[t._v("某个字段count不会统计字段为null值的数据行")]),t._v(" "),r("li",[t._v("字段有索引：count(*)≈count(1)>count(字段)>count(主键 id)")]),t._v(" "),r("li",[t._v("show table status 代替总行数 （故略计算）")])])])}),[],!1,null,null,null);r.default=a.exports}}]);