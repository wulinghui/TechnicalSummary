(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{495:function(a,t,r){"use strict";r.r(t);var e=r(7),i=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"semaphore"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#semaphore"}},[a._v("#")]),a._v(" Semaphore")]),a._v(" "),t("ul",[t("li",[a._v("它的作用是控制访问特定资源的线程数目")]),a._v(" "),t("li",[a._v("需求场景:: 资源访问，服务限流(Hystrix里限流就有基于信号量方式)。")]),a._v(" "),t("li",[a._v("public Semaphore(int permits, boolean fair)")])]),a._v(" "),t("h2",{attrs:{id:"api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[a._v("#")]),a._v(" API")]),a._v(" "),t("ul",[t("li",[a._v("acquire() 表示阻塞并获取许可")]),a._v(" "),t("li",[a._v("tryAcquire（int args,long timeout, TimeUnit unit）表示在有限时间内阻塞并获取许可")]),a._v(" "),t("li",[a._v("release() 表示释放许可")])]),a._v(" "),t("h1",{attrs:{id:"countdownlatch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[a._v("#")]),a._v(" CountDownLatch")]),a._v(" "),t("ul",[t("li",[a._v("能够使一个线程等待其他线程完成各自的工作后再执行")]),a._v(" "),t("li",[a._v("使用场景： Zookeeper分布式锁，Jmeter模拟高并发，开枪起跑")]),a._v(" "),t("li",[a._v("CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，表示所有的线程都完成了任务，然后等待的线程就可以恢复执行任务。")]),a._v(" "),t("li",[t("strong",[a._v("注意只能用一次")])])]),a._v(" "),t("h2",{attrs:{id:"api-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-2"}},[a._v("#")]),a._v(" API")]),a._v(" "),t("ul",[t("li",[a._v("countDown() 减一")]),a._v(" "),t("li",[a._v("await() 等待")])]),a._v(" "),t("h1",{attrs:{id:"cyclicbarrier"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier"}},[a._v("#")]),a._v(" CyclicBarrier")]),a._v(" "),t("ul",[t("li",[a._v("栅栏屏障，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。")]),a._v(" "),t("li",[a._v("应用场景： 可以用于多线程计算数据，最后合并计算结果的场景")])]),a._v(" "),t("h2",{attrs:{id:"api-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-3"}},[a._v("#")]),a._v(" API")]),a._v(" "),t("ul",[t("li",[a._v("超时时间的await和不带超时时间的await方法 ，这个await就是屏障点")])]),a._v(" "),t("h2",{attrs:{id:"和countdownlatch的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和countdownlatch的区别"}},[a._v("#")]),a._v(" 和CountDownLatch的区别")]),a._v(" "),t("ul",[t("li",[a._v("CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；")]),a._v(" "),t("li",[a._v("CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；")]),a._v(" "),t("li",[a._v("CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。")])]),a._v(" "),t("h1",{attrs:{id:"exchanger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#exchanger"}},[a._v("#")]),a._v(" Exchanger")]),a._v(" "),t("ul",[t("li",[a._v("当一个线程运行到exchange()方法时会阻塞，另一个线程运行到exchange()时，二者交换数据，然后执行后面的程序。")]),a._v(" "),t("li",[a._v("应用场景:: 遗传算法 和 校对工作/对账")])]),a._v(" "),t("h2",{attrs:{id:"api-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-4"}},[a._v("#")]),a._v(" API")]),a._v(" "),t("ul",[t("li",[a._v("V exchange(V x)   // 在这里等待另一个线程交互数据。")]),a._v(" "),t("li",[a._v("V exchange(V x, long timeout, TimeUnit unit)")])]),a._v(" "),t("h1",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_38293564/article/details/80558157",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java并发编程之CyclicBarrier详解"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/coslay/article/details/45242581",target:"_blank",rel:"noopener noreferrer"}},[a._v("java Exchanger原理"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=i.exports}}]);