(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{401:function(e,r,s){"use strict";s.r(r);var t=s(7),a=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"部署spring-cloud"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署spring-cloud"}},[e._v("#")]),e._v(" 部署spring-cloud")]),e._v(" "),r("p",[e._v("k8s算内核还不是pass  。"),r("br"),e._v("\npass是kbuleshrer，蓝鲸。")]),e._v(" "),r("h1",{attrs:{id:"部署mysql"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署mysql"}},[e._v("#")]),e._v(" 部署Mysql")]),e._v(" "),r("p",[e._v("多主多从（多个一主一从），分库分表，从库用于备份和读写分离。\nmysql扩容，独特扩容sts。  一主一从，读写分离。share proxy")]),e._v(" "),r("p",[e._v("一主一从 ：\n主节点:")]),e._v(" "),r("ol",[r("li",[e._v("有状态的Statefulset，PVC(RWO、存数据), SC(密码)，CM 和 service")]),e._v(" "),r("li",[e._v("Replicas=1  ； Image= MySQL：5.7.34")]),e._v(" "),r("li",[e._v("NodePort Service服务设置")]),e._v(" "),r("li",[e._v("配置文件： 设置开启binlog、server_id、需要复制的数据库。")]),e._v(" "),r("li",[e._v("进入pod内执行命令:  Slave 数据库使用来连接的账户并授权\n从节点:")])]),e._v(" "),r("ul",[r("li",[e._v("1/2/3同上")]),e._v(" "),r("li",[e._v("配置文件: 中继节点日志、server_id;")]),e._v(" "),r("li",[e._v("执行命令: 连接主数据库设置(master_host为主节点的serviceName)、启动 slave\n再主节点source加载业务的初始化数据。有些新项目引入了flyway可以不需要这一步。")])]),e._v(" "),r("p",[e._v("注意:")]),e._v(" "),r("ul",[r("li",[e._v("2个不同的配置文件，还有进pod里面去操作sql语句,设置权限相关内容。")]),e._v(" "),r("li",[e._v("mysql主从，pod崩溃恢复情况？  serviceName单个节点所以podIP会变，也没关系。")]),e._v(" "),r("li",[e._v("一个主对应一个从。")])]),e._v(" "),r("h1",{attrs:{id:"部署shardingsphere-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署shardingsphere-proxy"}},[e._v("#")]),e._v(" 部署Shardingsphere-Proxy")]),e._v(" "),r("p",[e._v("业务上都是用ShardingSphere-JDBC，proxy只是用于运维维护。")]),e._v(" "),r("ul",[r("li",[e._v("Deployment无状态的、SC共用mysql，CM、Service用loadBalancer、PersistentVolumeClaim(RWM、存放jar)")]),e._v(" "),r("li",[e._v("崩溃恢复？？  无状态服务，崩溃也没关系。")]),e._v(" "),r("li",[e._v("数据库不能随便扩展，sts的一般都不能。")])]),e._v(" "),r("h1",{attrs:{id:"部署redis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署redis"}},[e._v("#")]),e._v(" 部署redis")]),e._v(" "),r("ul",[r("li",[e._v("yaml文件: 有状态的Statefulset，动态pv模板(RWO、存数据),设置副本数为6, CM 和 service无头服务")]),e._v(" "),r("li",[e._v("jsonpath获得所有的ip:  kubectl get pods -l app=redis-cluster -n production -o  jsonpath='{range.items[*]}{.status.podIP}:6379 '")]),e._v(" "),r("li",[e._v("执行集群命令: redis-cli --cluster create 10.10.219.1:6379 10.10.219.57:6379 10.10.219.56:6379  10.10.109.100:6379 10.10.219.55:6379 10.10.109.69:6379 --cluster-replicas 1")])]),e._v(" "),r("p",[e._v("注意:  ip只能是pod的ip，最好是用sts的pod全域名(主机名不好使)，不能是serviceName。")]),e._v(" "),r("blockquote",[r("p",[e._v("这里还有修改/data/nodes.conf的nodeIP的脚本。 建议还是用sts的pod全域名。")])]),e._v(" "),r("p",[e._v("崩溃恢复：\nRedis集群中每个节点都有自己的NodeId，里面保存（/data/nodes.conf）了各个节点的信息，所以持久化了后pod就能获得这个文件去连接集群了。")]),e._v(" "),r("h1",{attrs:{id:"部署rocketmq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署rocketmq"}},[e._v("#")]),e._v(" 部署RocketMq")]),e._v(" "),r("p",[e._v("两主两从，同步模式：")]),e._v(" "),r("ul",[r("li",[e._v("NameServer")])]),e._v(" "),r("blockquote",[r("p",[e._v("客户端都连接指定多个NameServer。\nNameServer 需要部署多个节点，以保证 NameServer 的高可用。\nNameServer 本身是无状态，不产生数据的存储，是通过 Broker 心跳将 Topic 信息同步到NameServer 中。\n多个 NameServer 之间不会有数据的同步，是通过 Broker 向多个 NameServer 多写。")])]),e._v(" "),r("ul",[r("li",[e._v("Broker")])]),e._v(" "),r("blockquote",[r("p",[e._v("多个 Broker 可以形成一个 Broker 分组。每个 Broker 分组存在一个 Master 和多个 Slave 节点。\nMaster 节点，可提供读和写功能。Slave 节点，可提供读功能。\nMaster 节点会不断发送新的 CommitLog 给 Slave 节点。Slave 节点不断上报本地的\nCommitLog 已经同步到的位置给 Master 节点。\nSlave 节点会从 Master 节点拉取消费进度、Topic 配置等等。\n多个 Broker 分组，形成 Broker 集群。\nBroker 集群和集群之间，不存在通信与数据同步。\nBroker 可以配置同步刷盘或异步刷盘，根据消息的持久化的可靠性来配置。")])]),e._v(" "),r("p",[e._v("总结:")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("broker：\n4个yaml都是sts、service，动态存储模板，指定不同的配置文件。再配置文件中设置NameServer、brokerName(分组)\nbroker-a 主 1\nbroker-b 主 2\nbroker-a-s 从 1\nbroker-a-s 从 2")])]),e._v(" "),r("li",[r("p",[e._v("NameServer（注册中心）:  sts、 2个副本、无存储，客户端连接用pod全域名连接。")])]),e._v(" "),r("li",[r("p",[e._v("Console（可视化 web 界面） : Deployment、加上Ingress供外部访问。")])])]),e._v(" "),r("p",[e._v("崩溃恢复: 里面对应的配置文件NameServer是不变的。")]),e._v(" "),r("h1",{attrs:{id:"部署kafka"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署kafka"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://www.jianshu.com/p/af79350a6ddb",target:"_blank",rel:"noopener noreferrer"}},[e._v("部署kafka"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("zk : 2个service(一个hs无头、一个cs客户端连接)，sts、3副本、动态存储、selector设置亲和性(不部署再kafka、每个node只部署一个) , 设置PodDisruptionBudget保护至少一个节点")]),e._v(" "),r("p",[e._v("kafka : service无头，PodDisruptionBudget至少2个节点，sts、3副本、动态存储、selector设置亲和性，用zk的pod的DNS全域名连接zk.")]),e._v(" "),r("h1",{attrs:{id:"部署nacos"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署nacos"}},[e._v("#")]),e._v(" 部署Nacos")]),e._v(" "),r("ul",[r("li",[e._v("nacos单机会丢数据，内存数据库。")]),e._v(" "),r("li",[e._v("所以线上采用集群的nacos。")])]),e._v(" "),r("p",[e._v("具体配置:\nConfigMap 设置数据库。\nsts的网络是固定的，无头服务用pod名选址； 3个副本、开通tcp和http端口、NACOS_SERVERS环境变量设置3个主机名、不配置存储。\n设置Ingress用于页面访问。")]),e._v(" "),r("p",[e._v("nacos状态不对问题：  pod写全域名，别写podname-序号。")]),e._v(" "),r("h1",{attrs:{id:"部署业务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#部署业务"}},[e._v("#")]),e._v(" 部署业务")]),e._v(" "),r("p",[e._v("Deployment、设置HPA自动伸缩。Service的ClusterIP 和 Ingress。\nCM: 对应应用的配置文件。 里面中间件的地址都是serviceName，或者sts的Pod的DNS域名。\nSC: 密码是用上面中间件中创建的。(对应CM里面就是环境变量)")]),e._v(" "),r("p",[e._v("非生产的namespace：中间件都部署单机版的。\n日志文件: 用hostpath静态存储。  日志一般不写到pvc里面。    跟着节点走，在domenset里面部署elk收集到pvc里面。\nresources.limits: 限制和JVM内存保持好，否则OOM后会出现总删除/重启pod。")]),e._v(" "),r("p",[e._v("连不上redis：  集群不正常，重新初始化redis，看好配置文件。")]),e._v(" "),r("h1",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog.51cto.com/leejia/2584207?ivk_sa=1025922q",alt:"k8s环境通过DNS名称访问POD"}})]),e._v(" "),r("blockquote",[r("p",[e._v("直接访问pod的方式 : pod自动分配的ip、DNS名称访问（deployment会变、statefulset固定）\n"),r("img",{attrs:{src:"https://www.jb51.net/article/210827.htm",alt:"在K8s上部署Redis集群的方法步骤"}}),e._v("\n那为什么没有使用稳定的标志，Redis Pod也能正常进行故障转移呢？这涉及了Redis本身的机制。\n但是他这里是用了sts的pod全域名，作为稳定的网络标识。")])]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://nacos.io/zh-cn/docs/use-nacos-with-kubernetes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("官网: Kubernetes Nacos"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("Tekton    ops系统。  二次开发： Jenkins是封装 Api；Tekton是组合 Task就行了。")])])}),[],!1,null,null,null);r.default=a.exports}}]);