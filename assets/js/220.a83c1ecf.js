(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{581:function(t,n,s){"use strict";s.r(n);var a=s(7),l=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"学习方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#学习方式"}},[t._v("#")]),t._v(" 学习方式")]),t._v(" "),n("p",[t._v("如何快速的掌握数据结构与算法")]),t._v(" "),n("p",[t._v("1.什么是数据结构？什么是算法？\n数据结构： 就是一个能组在一起的集合对象。比如数组 链表 队列等。\n算法：就是解决问题的")]),t._v(" "),n("p",[t._v("2.数据结构与算法要学哪些内容？\n"),n("img",{attrs:{src:"%E5%85%A5%E9%97%A8%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95_files/1.jpg",alt:""}}),t._v(" "),n("img",{attrs:{src:"%E5%85%A5%E9%97%A8%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95_files/2.jpg",alt:""}}),t._v(" "),n("img",{attrs:{src:"%E5%85%A5%E9%97%A8%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95_files/3.jpg",alt:""}})]),t._v(" "),n("blockquote",[n("p",[t._v("数论普通人都重要,基础中的高级。\n图论属于进阶（最复杂的数据结构），知识图谱、大数据、社交。\n"),n("img",{attrs:{src:"%E5%85%A5%E9%97%A8%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95_files/4.jpg",alt:""}})])]),t._v(" "),n("p",[t._v("3.面对这么多的知识点，我们应该怎么学习？\n学习目的：\n（1）提升能力的：全部学\n（2）突击面试的：注意几个经典的：【数组】 链表 排序算法 二叉树 红黑树 B-Tree B+Tree\n（3）进阶的：树论+图论+我的专项+每节课的理论部分")]),t._v(" "),n("h1",{attrs:{id:"为什么要学习数据结构与算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要学习数据结构与算法"}},[t._v("#")]),t._v(" 为什么要学习数据结构与算法")]),t._v(" "),n("ol",[n("li",[t._v("BAT一线互联网公司面试必问技术？")]),t._v(" "),n("li",[t._v("如果你不想做一辈子的CRUD工程师")]),t._v(" "),n("li",[t._v("架构师必备，写出框架级的高性能代码")]),t._v(" "),n("li",[t._v("提升自己的能力，不被行业淘汰")]),t._v(" "),n("li",[t._v("所有计算机类的基础，几十年的时间才会淘汰，可以说学了就够一辈子用。")])]),t._v(" "),n("blockquote",[n("p",[t._v("总之是一门被人们小看的性价比极高的基础，重要但不常用，实用却又难学。")])]),t._v(" "),n("h1",{attrs:{id:"书籍、网站推荐"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#书籍、网站推荐"}},[t._v("#")]),t._v(" 书籍、网站推荐")]),t._v(" "),n("p",[t._v("1.数据结构：\n（1）严蔚敏版 数据结构与算法（都可以）\n（2）大话数据结构（都可以）")]),t._v(" "),n("p",[t._v("2.算法：\n（1）基础级：刘汝佳 算法竞赛入门经典（两本，还有一个是习题）\n（2）进阶级：刘汝佳黑书 算法导论；非常难，非算法行业慎入")]),t._v(" "),n("p",[t._v("网站：\n（1）力扣:https://leetcode-cn.com/  一般常用刷题的网站。\n（2）POJ  北大的题库，比较难。  (有些公司的题就在里面)\n(3) HDU  杭州科技大学的题库（和POJ类似）。")]),t._v(" "),n("p",[t._v("书籍:\njava有关的基础： 《java编程思想》")]),t._v(" "),n("h1",{attrs:{id:"算法的特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法的特性"}},[t._v("#")]),t._v(" 算法的特性")]),t._v(" "),n("p",[t._v("五个特征：")]),t._v(" "),n("ul",[n("li",[t._v("有穷性 : 不是死循环。While(true){}")]),t._v(" "),n("li",[t._v("确定性 : 能有确定的结果")]),t._v(" "),n("li",[t._v("可行性 : 可以解决实际问题。")]),t._v(" "),n("li",[t._v("有输入有输出")])]),t._v(" "),n("p",[t._v("设计原则：")]),t._v(" "),n("ul",[n("li",[t._v("正确性")]),t._v(" "),n("li",[t._v("可读性")]),t._v(" "),n("li",[t._v("健壮性 bug( 写出代码很少有bug，而且系统比较稳定 )")]),t._v(" "),n("li",[t._v("（重要）高效率与低存储: 内存+CPU 堆栈内存OOM (内存占用最小，CPU占用最小，运算速度最快)")])]),t._v(" "),n("p",[t._v("评价算法的两个重要指标:\n占据整个学习的半壁江山，接下来我们会重点学习时间复杂度的计算\n时间复杂度:运行一个程序所花费的时间。O()\n空间复杂度：运行程序所需要的内存  OOM")]),t._v(" "),n("h1",{attrs:{id:"时间复杂度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("时间复杂度计算的意义: 怎么测试接口的性能的？ 最好的就是，用代码分析。也就是时间复杂度")])]),t._v(" "),n("li",[n("p",[t._v("时间复杂度表示方法：大O表示法。 O(1),O(n),O(nlogn),O(n^2),O(n+1),O(logn),O(n!)\no(1）< o(log2n)<o(n)<o(nlog2n)<o(n^2)<o(n^3)<o(2^n)<o(n!)<o(n^n)")])]),t._v(" "),n("li",[n("p",[t._v("时间复杂度如何来分析\n（1）找for while 递归。而且要找循环量最大的那一段\n（2）同级循环怎么计算")])]),t._v(" "),n("li",[n("p",[t._v("我们怎么找时间复杂度：\n1.找到有循环的地方，\n2.找有网络请求（RPC，远程调用，分布式，数据库请求）的地方。\n就是测试时间：log打印，计算平均时间。\n3.处理业务的地方。指的是某一段代码。")])]),t._v(" "),n("li",[n("p",[t._v("几种常见的时间复杂度分析：\n计算机忽略掉常数 :  计算时间复杂度 往往是计算比较大的 而且是不确定的数，如果已经确定了，那么就不用计算了，也是我们说的常量。\n找运行最多的 : 注意有个规律，有加减法的时候，找次数最高的那个")])])]),t._v(" "),n("ul",[n("li",[t._v("常数：O(1)  1表示是常数，所有能确定的数字我们都用O(1)，O(1000)=>o(1)")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t\tint a = 1;\t\t//1次 O(1)\n\t\tfor(int i = 0 ;i < 3;i++){//这里会运行几次？4次 在第4次的时候结束 跳出 i=3 (0 1 2 3)\n\t\t\ta = a + 1;\t\t\t//这里运行几次？ 3次 O(1)? n+1 n 1 O(3)? => O(1)\n\t\t}\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br")])]),n("ul",[n("li",[t._v("对数：O(logn)")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t\tint n = Integer.MAX_VALUE;\t\t//表示n是未知\n\t\t\n\t\tint i = 1;\n\t\twhile( i <= n){\n\t\t\t i = i * 2;\t\t// O(log2n)  =>  O(logn)\n\t\t}\n\t\twhile( i <= n){\n\t\t\t i = i * 3;\t\t// O(log3n)   => O(logn)\n\t\t}\n\t\t//i的值：2 4 8 16 32,=》2^0,2^1,2^2,2^3,.....2^n\n\t\t//===> 2^x=n =>求出x就是我们运行的次数 => x=log2n =>计算机忽略掉常数 => x = logn =>O(logn)\n\t\t//二分查找 为什么是logn的算法？   每次找一半。就是O(logN)\n\t\t//1~100 找69这个数\n\t\t//50:(1+100)/2 = 50\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br")])]),n("ul",[n("li",[t._v("线性：O(n)")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t\tfor(i = 0 ; i < n;i++){\n\t\t\ta = a +1;\t\t\t//运行了多少次？O(n) n一定是一个未知的，如果n是已知6的就是 O(1)\n\t\t}\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br")])]),n("ul",[n("li",[t._v("线性对数：O(nlogn)")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("            n * logn  // \n\t\t\tfor(int j = 0 ; j < n ;j++){\n\t\t\t\twhile ( i <= n){\n\t\t\t\t\ti = i * 2;\n\t\t\t\t}\n\t\t\t}\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br")])]),n("ul",[n("li",[t._v("平方：O(n^2)")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t\t\tfor(i = 0 ; i < n;i++){\t// 乘法 n次\n\t\t\t\tfor(int j = 0 ; j < n ;j ++){\t\t//n次\n\t\t\t\t\ta = a +1;\t\t\t//运行了多少次？\t\tO(n^2)\n\t\t\t\t}\n\t\t\t} \n\t\t\tn * n =  n^2  => O(n^2) \n\t\t\n\t\t// 冒泡排序。\t\n\t\tfor(i = 0 ; i < n;i++){\t// 乘法 n次\n\t\t\tfor(int j = i ; j < n ;j ++){\t\t//n次 \n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * 外面的循环次数是确定的 O(n) n次，1 2 3 4 。。。n\n\t\t\t\t\t\t * \n\t\t\t\t\t\t * i=n 运行1次\n\t\t\t\t\t\t * i=n-1 运行2次\n\t\t\t\t\t\t * .\n\t\t\t\t\t\t * .\n\t\t\t\t\t\t * .\n\t\t\t\t\t\t * i=1 运行n次\n\t\t\t\t\t\t * \n\t\t\t\t\t\t * 1,2,3 …… n次 最后里面这层要运行多少次？1+2+3+……+n=n*(n+1)/2 => \n\t\t\t\t\t\t * \n\t\t\t\t\t\t */\n\t\t\t\ta = a +1;\t\t\t//运行了多少次？\tn*(n+1)/2 => O(n^2); => (n^2+n)/2 =>  忽略常数2 => n^2 + n  => 找次数最高的那个  => n^2  => O(n^2)\n\t\t\t}\n\t\t}\n\t\tn *  ( (n*(n+1))/2 )  =  (n^2+n)/2    => n^2  =>  O(n^2)\n\t\t\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br"),n("span",{staticClass:"line-number"},[t._v("16")]),n("br"),n("span",{staticClass:"line-number"},[t._v("17")]),n("br"),n("span",{staticClass:"line-number"},[t._v("18")]),n("br"),n("span",{staticClass:"line-number"},[t._v("19")]),n("br"),n("span",{staticClass:"line-number"},[t._v("20")]),n("br"),n("span",{staticClass:"line-number"},[t._v("21")]),n("br"),n("span",{staticClass:"line-number"},[t._v("22")]),n("br"),n("span",{staticClass:"line-number"},[t._v("23")]),n("br"),n("span",{staticClass:"line-number"},[t._v("24")]),n("br"),n("span",{staticClass:"line-number"},[t._v("25")]),n("br"),n("span",{staticClass:"line-number"},[t._v("26")]),n("br"),n("span",{staticClass:"line-number"},[t._v("27")]),n("br"),n("span",{staticClass:"line-number"},[t._v("28")]),n("br")])]),n("ul",[n("li",[t._v("N次方：O(n^n)")])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t例如n张牌的洗牌： 结果有 n * (n-1) * (n-2)  .... * 1  => n! => n^n  => O(n^n)\n\t不常见。\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br")])]),n("ol",{attrs:{start:"6"}},[n("li",[t._v("效率目标")])]),t._v(" "),n("p",[t._v("学了时间复杂度，那我们的目的就是要把代码写到最优，效率最高；")]),t._v(" "),n("p",[t._v("O(1)>O(logn)>O(n)>O(nlogn)>O(n^2)>O(n^x)>O(n^n)\nO(1)>O(logn)>O(n)>O(nlogn) 效果都是很好的。几乎优化的空间不是很大。\n优化的目标就是要往O（1）的方向接近。\n比如:\n登录：判断用户名密码O(1)到数据库里查记录；已经没办法优化逻辑代码,只能用其他手段如: 分布式 缓存。\n列表的接口：排序，冒泡排序；=>找更优秀的排序算法 快速排序，归并排序，堆排序。")]),t._v(" "),n("ol",{attrs:{start:"7"}},[n("li",[t._v("项目中常见\n最坏情况，最好情况，平均情况时间复杂度；  一般是指平均的时间复杂度")])]),t._v(" "),n("h1",{attrs:{id:"空间复杂度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[t._v("#")]),t._v(" 空间复杂度")]),t._v(" "),n("p",[t._v("1.空间复杂度分析的意义：找花了内存的地方。数据")]),t._v(" "),n("p",[t._v("2.如何找出程序的空间复杂度：开了空间的地方， 比如 数组 链表，缓存对象，递归(的层级也占队列)")]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\t\t/*\n\t\tint data[100];\n\t\tList<>; list.add();\n\t\tMap put\n\t\tSet add\n\t\tQueue\n\t\tObject \n\t\t*/\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br")])]),n("p",[t._v("3.一般怎么改进？\n尽量少的内存使用。")])])}),[],!1,null,null,null);n.default=l.exports}}]);