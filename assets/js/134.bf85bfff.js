(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{493:function(e,t,a){"use strict";a.r(t);var r=a(7),_=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"类图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[e._v("#")]),e._v(" 类图")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1182892/201711/1182892-20171122100317930-842768608.png",alt:""}})]),e._v(" "),t("h1",{attrs:{id:"queue顶层接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue顶层接口"}},[e._v("#")]),e._v(" Queue顶层接口")]),e._v(" "),t("h1",{attrs:{id:"deque接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deque接口"}},[e._v("#")]),e._v(" Deque接口")]),e._v(" "),t("p",[e._v("继承自Queue ，Deque定义为双端队列，即队首队尾都有出入口，可以实现双端出入。")]),e._v(" "),t("h2",{attrs:{id:"jdk的实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk的实现类"}},[e._v("#")]),e._v(" jdk的实现类")]),e._v(" "),t("ul",[t("li",[e._v("ArrayDeque")]),e._v(" "),t("li",[e._v("LinkedList")]),e._v(" "),t("li",[e._v("ConcurrentLinkedDeque")])]),e._v(" "),t("h1",{attrs:{id:"blockingqueue接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue接口"}},[e._v("#")]),e._v(" BlockingQueue接口")]),e._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("ul",[t("li",[e._v("继承自Queue")]),e._v(" "),t("li",[e._v("BlockingQueue用于解决并发生产者 - 消费者问题")]),e._v(" "),t("li",[e._v("特性:: 是在任意时刻只有一个线程可以进行take或者put操作，并且 BlockingQueue提供了超时return null的机制")])]),e._v(" "),t("h2",{attrs:{id:"队列类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列类型"}},[e._v("#")]),e._v(" 队列类型")]),e._v(" "),t("ul",[t("li",[e._v("有限/无限队列")]),e._v(" "),t("li",[e._v("阻塞/非阻塞队列")]),e._v(" "),t("li",[e._v("优先级队列")]),e._v(" "),t("li",[e._v("单端/双端队列")]),e._v(" "),t("li",[e._v("传输队列")])]),e._v(" "),t("h2",{attrs:{id:"队列数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列数据结构"}},[e._v("#")]),e._v(" 队列数据结构")]),e._v(" "),t("ul",[t("li",[e._v("通常用链表或者数组实现")]),e._v(" "),t("li",[e._v("一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）和优先级 队列")]),e._v(" "),t("li",[e._v("主要操作：入队（EnQueue）与出队（Dequeue）")])]),e._v(" "),t("h2",{attrs:{id:"blockingqueue-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue-api"}},[e._v("#")]),e._v(" BlockingQueue API")]),e._v(" "),t("h3",{attrs:{id:"添加元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加元素"}},[e._v("#")]),e._v(" 添加元素")]),e._v(" "),t("p",[e._v("非阻塞：")]),e._v(" "),t("blockquote",[t("p",[e._v("add()  // 如果插入成功则返回 true，否则抛出 IllegalStateException 异常")]),e._v(" "),t("p",[e._v("offer() // 如果插入成功则返回 true，否则返回 false")])]),e._v(" "),t("p",[e._v("阻塞")]),e._v(" "),t("blockquote",[t("p",[e._v("put()  // 将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入")]),e._v(" "),t("p",[e._v("offer(E e, long timeout, TimeUnit unit) // 尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入")])]),e._v(" "),t("h3",{attrs:{id:"检索元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#检索元素"}},[e._v("#")]),e._v(" 检索元素")]),e._v(" "),t("p",[e._v("take()  // 获取队列的头部元素并将其删除，如果队列为空，则阻塞并等待元素变为可用")]),e._v(" "),t("p",[e._v("poll(long timeout, TimeUnit unit)  // 检索并删除队列的头部，如有必要，等待指定的等待时间以使元素可用，如果超时，则返回 null")]),e._v(" "),t("h2",{attrs:{id:"常见的阻塞队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的阻塞队列"}},[e._v("#")]),e._v(" 常见的阻塞队列")]),e._v(" "),t("h3",{attrs:{id:"arrayblockingqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arrayblockingqueue"}},[e._v("#")]),e._v(" ArrayBlockingQueue")]),e._v(" "),t("ul",[t("li",[e._v("由数组支持的有界队列")]),e._v(" "),t("li",[e._v("在线程池中有比较多的应用，生产者消费者场景")]),e._v(" "),t("li",[e._v("基于ReentrantLock保证线程安全，根据Condition实现队列满时的阻塞")])]),e._v(" "),t("h3",{attrs:{id:"linkedblockingqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedblockingqueue"}},[e._v("#")]),e._v(" LinkedBlockingQueue")]),e._v(" "),t("ul",[t("li",[e._v("由链接节点支持的可选有界(值非常大相当于无界)队列")]),e._v(" "),t("li",[e._v("会加锁保证线程安全")]),e._v(" "),t("li",[e._v("设计生产者 - 消费者模型时最重要的是 消费者应该能够像生产者向队列添加消息一样快地消费消息 。否则，内存可能会填满，然后就会得到一个 OutOfMemory 异常。")]),e._v(" "),t("li",[e._v("Executors.newFixedThreadPool() 就是用这个队列")])]),e._v(" "),t("h3",{attrs:{id:"linkedblockingdeque"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedblockingdeque"}},[e._v("#")]),e._v(" LinkedBlockingDeque")]),e._v(" "),t("p",[e._v("由链表构成的双向阻塞队列，类似于LinkedBlockingQueue，多了Deque接口的实现.")]),e._v(" "),t("h3",{attrs:{id:"concurrentlinkedqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrentlinkedqueue"}},[e._v("#")]),e._v(" ConcurrentLinkedQueue")]),e._v(" "),t("p",[e._v("基于链表形式的队列，通过compare and swap(简称CAS)协议的方式，来保证多线程情况下数据的安全，不加锁，主要使用了Java中的sun.misc.Unsafe类来实现")]),e._v(" "),t("h3",{attrs:{id:"priorityblockingqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priorityblockingqueue"}},[e._v("#")]),e._v(" PriorityBlockingQueue")]),e._v(" "),t("p",[e._v("由优先级堆支持的无界优先级阻塞队列")]),e._v(" "),t("h3",{attrs:{id:"delayqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delayqueue"}},[e._v("#")]),e._v(" DelayQueue")]),e._v(" "),t("ul",[t("li",[e._v("由优先级堆支持的、基于时间的调度队列")]),e._v(" "),t("li",[e._v("由优先级堆支持的、基于时间的调度队列，内部基于无界队列PriorityQueue实现，而无界队列基于数组的扩容实现。")]),e._v(" "),t("li",[e._v("队列内部会根据时间优先级进行排序。延迟类线程池周期执行。")])]),e._v(" "),t("h3",{attrs:{id:"synchronousqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronousqueue"}},[e._v("#")]),e._v(" SynchronousQueue")]),e._v(" "),t("ul",[t("li",[e._v("队列不存储数据，所以没有大小，也无法进行迭代；")]),e._v(" "),t("li",[e._v("插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然；")]),e._v(" "),t("li",[e._v("该队列由两种数据结构组成，即先入先出的队列和后入先出的栈；")]),e._v(" "),t("li",[e._v("在初始化的时候，是可以选择使用队列或者栈的，默认是栈；")]),e._v(" "),t("li",[e._v("Executors.newCachedThreadPool() 就是用的这个队列")])]),e._v(" "),t("h3",{attrs:{id:"linkedtransferqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedtransferqueue"}},[e._v("#")]),e._v(" LinkedTransferQueue")]),e._v(" "),t("ul",[t("li",[e._v("可以看做SynchronousQueue和LinkedBlockingQueue的结合体")]),e._v(" "),t("li",[e._v("可以自己控制存元素是否需要阻塞线程，transfer() 会阻塞线程.   一般的put()  offer() 则入队。")]),e._v(" "),t("li",[e._v("取元素和SynchronousQueue一样，都会等待有新的元素才进入匹配到.")])]),e._v(" "),t("h1",{attrs:{id:"blockingdeque接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockingdeque接口"}},[e._v("#")]),e._v(" BlockingDeque接口")]),e._v(" "),t("p",[e._v("继承BlockingQueue，Deque")]),e._v(" "),t("h2",{attrs:{id:"jdk的实现类-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk的实现类-2"}},[e._v("#")]),e._v(" jdk的实现类")]),e._v(" "),t("ul",[t("li",[e._v("LinkedBlockingDeque")])]),e._v(" "),t("h1",{attrs:{id:"无锁并发队列框架-disruptor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无锁并发队列框架-disruptor"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://cxybb.com/article/weixin_46300935/120836731",target:"_blank",rel:"noopener noreferrer"}},[e._v("无锁并发队列框架 Disruptor"),t("OutboundLink")],1)]),e._v(" "),t("h1",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/lemon-flm/p/7877898.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("java队列——queue详细分析"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/368548774",target:"_blank",rel:"noopener noreferrer"}},[e._v("只是给面试官讲了18种Java队列，竟然当场拿到offer！网友：牛批"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000016460411",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java多线程进阶（三八）—— J.U.C之collections框架：LinkedTransferQueue"),t("OutboundLink")],1)]),e._v(" "),t("blockquote",[t("p",[e._v("功能一 ： 可以控制生产者阻塞。 保证生产的消息一定有人消费。\n比如: 当我们不想生产者过度生产消息时，TransferQueue可能非常有用，可避免发生OutOfMemory错误。在这样的设计中，消费者的消费能力将决定生产者产生消息的速度。")]),e._v(" "),t("p",[e._v("什么这个用put()  offer() 有界队列也可以实现??那么请看")]),e._v(" "),t("p",[e._v("功能二: 当有消费者线程阻塞等待时，调用transfer方法的生产者线程不会将元素存入队列，而是直接将元素传递给消费者；插队消费，你服不??")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/shangxiaofei/p/5707552.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("java多线程之：SynchronousQueue队列"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);