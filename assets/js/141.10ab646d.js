(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{501:function(t,e,r){"use strict";r.r(e);var a=r(7),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"高级用法-扩展点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级用法-扩展点"}},[t._v("#")]),t._v(" 高级用法(扩展点)")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://blog.csdn.net/likewindy/article/details/51396576",target:"_blank",rel:"noopener noreferrer"}},[t._v("MyBatis之databaseIdProvider多数据库支持"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/TangKenny/article/details/113680711",target:"_blank",rel:"noopener noreferrer"}},[t._v("设置vfs 可以扩展xml文件的来源。"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_42412601/article/details/104645211",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mybatis四大核心对象之插件编写与原理"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/w_yunlong/article/details/79201509",target:"_blank",rel:"noopener noreferrer"}},[t._v("LanguageDriver实现动态 SQL"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/nmgrd/article/details/77198976",target:"_blank",rel:"noopener noreferrer"}},[t._v("mybatis之XMLLanguageDriver使用方式例子"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://dev-preview.cnblogs.com/niujifei/p/15312252.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MyBatis（十一）扩展：自定义类型处理器"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.cn/post/6854573216359415822",target:"_blank",rel:"noopener noreferrer"}},[t._v("MyBatis 添加元数据自定义元素标签"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/seasonsbin/article/details/116998082",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mybatis PropertyTokenizer，属性分词器工具类解析"),e("OutboundLink")],1)])]),t._v(" "),e("h1",{attrs:{id:"核心类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心类"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"http://www.mybatis.cn/archives/715.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("核心类"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[t._v("SqlSessionFactoryBuilder -》 SqlSessionFactory -》 SqlSession")]),t._v(" "),e("li",[t._v("SqlSession， 作为MyBatis工作的主要顶层API，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务")]),t._v(" "),e("li",[t._v("Executor，sql执行；MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护")]),t._v(" "),e("li",[t._v("StatementHandler，封装了JDBC Statement操作，负责对JDBC Statement的操作，如设置参数、将Statement结果集转换成List集合。")]),t._v(" "),e("li",[t._v("ParameterHandler，参数映射；负责对用户传递的参数转换成JDBC Statement 所需要的参数")]),t._v(" "),e("li",[t._v("ResultSetHandler，结果集映射；负责将JDBC返回的ResultSet结果集对象转换成List类型的集合")]),t._v(" "),e("li",[t._v("TypeHandler，负责Java数据类型和JDBC数据类型之间的映射和转换")]),t._v(" "),e("li",[t._v("MappedStatement，维护了一条select|update|delete|insert节点的封装")]),t._v(" "),e("li",[t._v("SqlSource，sql获取/解析/动态sql；负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回")]),t._v(" "),e("li",[t._v("BoundSql，表示动态生成的SQL语句以及相应的参数信息")]),t._v(" "),e("li",[t._v("Configuration，MyBatis所有的配置信息都维持在Configuration对象之中")]),t._v(" "),e("li",[t._v("MapperProxyFactory ，jdk动态代理创建Mapper对象。")])]),t._v(" "),e("h1",{attrs:{id:"主体流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主体流程"}},[t._v("#")]),t._v(" 主体流程")]),t._v(" "),e("h2",{attrs:{id:"构建sqlsessionfactory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建sqlsessionfactory"}},[t._v("#")]),t._v(" 构建SqlSessionFactory")]),t._v(" "),e("p",[e("strong",[t._v("SqlSessionFactoryBuilder")]),t._v("  解析xml中的properties、settings、日志、别名、插件、Factory、environment、databaseIdProviderElement、typeHandlerElement 、mapperElement 节点信息 生成 "),e("strong",[t._v("Configuration")]),t._v("  再构建"),e("strong",[t._v("SqlSessionFactory")])]),t._v(" "),e("h2",{attrs:{id:"解析mapper的5种形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析mapper的5种形式"}},[t._v("#")]),t._v(" 解析mapper的5种形式")]),t._v(" "),e("p",[t._v("xml中的namespace、class、package 最终都调用"),e("strong",[t._v("MapperRegistry.addMapper")]),t._v("方法放到"),e("strong",[t._v("Configuration#mapperRegistry.knownMappers")]),t._v(" 中保存。")]),t._v(" "),e("p",[t._v("resource、url 调用"),e("strong",[t._v("XMLMapperBuilder#parse")]),t._v("方法放到"),e("strong",[t._v("Configuration#mappedStatements")]),t._v("中保存。")]),t._v(" "),e("h2",{attrs:{id:"opensession过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#opensession过程"}},[t._v("#")]),t._v(" openSession过程")]),t._v(" "),e("p",[t._v("从"),e("strong",[t._v("Configuration")]),t._v("中获得环境变量  》》 构建"),e("strong",[t._v("TransactionFactory")]),t._v("并获得事务 》》 构建"),e("strong",[t._v("Executor")]),t._v("且放到"),e("strong",[t._v("SqlSession")]),t._v("中")]),t._v(" "),e("h2",{attrs:{id:"执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[t._v("#")]),t._v(" 执行过程")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("MapperProxyFactory")]),t._v("通过jdk动态代理将"),e("strong",[t._v("MapperProxy")]),t._v("的Handle生成接口的实现类，再invoke的方法内部执行；")]),t._v(" "),e("li",[e("strong",[t._v("SqlSession")]),t._v("的查询操作，具体是先获得"),e("strong",[t._v("MappedStatement")]),t._v("，执行"),e("strong",[t._v("Executor")]),t._v("的真正执行的接口；")]),t._v(" "),e("li",[t._v("获得"),e("strong",[t._v("BoundSql")]),t._v("，构建缓存key并做缓存相关操作，或者再构建"),e("strong",[t._v("StatementHandler")]),t._v("，内部构建了"),e("strong",[t._v("ParameterHandler")]),t._v("，"),e("strong",[t._v("ResultSetHandler")]),t._v("，再通过"),e("strong",[t._v("TypeHandler")]),t._v("执行并封装结果集")]),t._v(" "),e("li",[t._v("最后commit，清除一级缓存，等等收尾工作。")])]),t._v(" "),e("h1",{attrs:{id:"运用到的设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运用到的设计模式"}},[t._v("#")]),t._v(" 运用到的设计模式")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("Builder模式")]),t._v(" "),e("th",[t._v("SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder、MapperAnnotationBuilder、MapperBuilderAssistant")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("工厂模式")]),t._v(" "),e("td",[t._v("SqlSessionFactory、ObjectFactory、MapperProxyFactory  、ObjectWrapperFactory 、reflectorFactory、TransactionFactory")])]),t._v(" "),e("tr",[e("td",[t._v("单例模式")]),t._v(" "),e("td",[t._v("ErrorContext   利用threadLocal每个线程中是单例的,")])]),t._v(" "),e("tr",[e("td",[t._v("代理模式")]),t._v(" "),e("td",[t._v("MapperProxy、ConnectionLogger；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果ProxyFactory.createProxy")])]),t._v(" "),e("tr",[e("td",[t._v("组合模式")]),t._v(" "),e("td",[t._v("SqlNode 解析sql.xml语句")])]),t._v(" "),e("tr",[e("td",[t._v("模板方法模式")]),t._v(" "),e("td",[t._v("BaseExecutor和SimpleExecutor、BaseTypeHandler 、BaseStatementHandler")])]),t._v(" "),e("tr",[e("td",[t._v("适配器模式")]),t._v(" "),e("td",[t._v("Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现")])]),t._v(" "),e("tr",[e("td",[t._v("装饰者模式")]),t._v(" "),e("td",[t._v("Cache缓存、CachingExecutor二级缓存执行器")])]),t._v(" "),e("tr",[e("td",[t._v("门面模式")]),t._v(" "),e("td",[t._v("SqlSession，作为顶层的API给客户端使用， 不执行具体的内容，都是交给对应的Executor去执行； 日志也是一个门面")])]),t._v(" "),e("tr",[e("td",[t._v("迭代器模式")]),t._v(" "),e("td",[t._v("PropertyTokenizer属性分词器")])])])]),t._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/yunianzeng/p/11826449.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("mybatis的缓存机制：一级缓存和二级缓存的区别"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("一级缓存的作用域是一个sqlsession内，默认开启；二级缓存作用域是针对mapper进行缓存。")]),t._v(" "),e("p",[t._v("一级缓存时执行commit，close，增删改等操作，就会清空当前的一级缓存；当对SqlSession执行更新操作（update、delete、insert）后并执行commit时，不仅清空其自身的一级缓存（执行更新操作的效果），也清空二级缓存（执行commit()的效果）。")]),t._v(" "),e("p",[t._v("不管是不是相同的session,只要mapper的namespace相同,可能共享缓存，如果开启了二级缓存，那么在关闭sqlsession后(close)，才会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);