(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{566:function(t,e,_){"use strict";_.r(e);var r=_(7),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("事务并发访问同一数据资源的情况主要就分为"),e("code",[t._v("读-读")]),t._v("、"),e("code",[t._v("写-写")]),t._v("和"),e("code",[t._v("读-写")]),t._v("三种。")]),t._v(" "),e("p",[e("code",[t._v("读-读")]),t._v(" 即并发事务同时访问同一行数据记录。由于两个事务都进行只读操作，不会对记录造成任何影响，因此并发读完全允许。")]),t._v(" "),e("p",[e("code",[t._v("写-写")]),t._v(" 即并发事务同时修改同一行数据记录。这种情况下可能导致"),e("code",[t._v("脏写")]),t._v("问题，这是任何情况下都不允许发生的，因此只能通过"),e("code",[t._v("加锁")]),t._v("实现，也就是当一个事务需要对某行记录进行修改时，首先会先给这条记录加锁，如果加锁成功则继续执行，否则就排队等待，事务执行完成或回滚会自动释放锁。")]),t._v(" "),e("p",[e("code",[t._v("读-写")]),t._v(" 即一个事务进行读取操作，另一个进行写入操作。这种情况下可能会产生"),e("code",[t._v("脏读")]),t._v("、"),e("code",[t._v("不可重复读")]),t._v("、"),e("code",[t._v("幻读")]),t._v("。最好的方案是"),e("strong",[t._v("读操作利用多版本并发控制（"),e("code",[t._v("MVCC")]),t._v("），写操作进行加锁")]),t._v("。")]),t._v(" "),e("p",[t._v("可以看到锁主要解决写，写 的场景")]),t._v(" "),e("h1",{attrs:{id:"锁分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁分类"}},[t._v("#")]),t._v(" 锁分类")]),t._v(" "),e("h2",{attrs:{id:"从性能上"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从性能上"}},[t._v("#")]),t._v(" 从性能上")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("乐观锁(用版本对比来实现)")]),t._v(" "),e("blockquote",[e("p",[t._v("不是数据库自带的，需要我们自己去实现。")])])]),t._v(" "),e("li",[e("p",[t._v("悲观锁")]),t._v(" "),e("blockquote",[e("p",[t._v("悲观锁是由数据库自己实现了,就是写锁，for update")])])])]),t._v(" "),e("h2",{attrs:{id:"从对数据库操作-锁的产生"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从对数据库操作-锁的产生"}},[t._v("#")]),t._v(" 从对数据库操作（锁的产生）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("读锁（共享锁，S锁(Shared)） ： 针对同一份数据，多个读操作可以同时进行而不会互相影响")]),t._v(" "),e("blockquote",[e("p",[t._v("InnoDB通过使用lock in share mode加读锁，但是注意"),e("code",[t._v("只锁覆盖索引")]),t._v("，可以更新id主键相关的内容")])])]),t._v(" "),e("li",[e("p",[t._v("写锁（排它锁，X锁(eXclusive)） ： 写锁（排它锁，X锁(eXclusive)）")]),t._v(" "),e("blockquote",[e("p",[t._v("InnoDB所有的DML操作默认加写锁。")]),t._v(" "),e("p",[t._v("select可以通过for update加写锁，并且会锁住所有索引，不仅仅是索引覆盖的索引。")]),t._v(" "),e("p",[t._v("所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。但是注意在MyISAM引擎中因为读也会自动加上读锁，所以使用排它锁的时候是不能去读的,这点要和InnoDB区别开")])])])]),t._v(" "),e("p",[t._v("读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞")]),t._v(" "),e("h2",{attrs:{id:"从对数据操作的粒度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从对数据操作的粒度"}},[t._v("#")]),t._v(" 从对数据操作的粒度")]),t._v(" "),e("h3",{attrs:{id:"全局锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[t._v("#")]),t._v(" 全局锁")]),t._v(" "),e("p",[t._v("全局锁即对整个数据库实例加锁，使得整个库处于只读状态，会阻塞DML和DDL语句。")]),t._v(" "),e("h3",{attrs:{id:"表锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[t._v("#")]),t._v(" 表锁")]),t._v(" "),e("ul",[e("li",[t._v("每次操作锁住整张表，一般用在整表数据迁移的场景。")]),t._v(" "),e("li",[t._v("开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低")])]),t._v(" "),e("h4",{attrs:{id:"操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[t._v("#")]),t._v(" 操作")]),t._v(" "),e("ul",[e("li",[t._v("手动增加表锁 ： "),e("code",[t._v("lock table 表名称 read(write),表名称2 read(write);")])]),t._v(" "),e("li",[t._v("查看表上加过的锁: "),e("code",[t._v("show open tables;")])]),t._v(" "),e("li",[t._v("删除表锁 : "),e("code",[t._v("unlock tables;")])])]),t._v(" "),e("h3",{attrs:{id:"行锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[t._v("#")]),t._v(" 行锁")]),t._v(" "),e("ul",[e("li",[t._v("每次操作锁住一行数据。")]),t._v(" "),e("li",[t._v("开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。")]),t._v(" "),e("li",[t._v("InnoDB支持行级锁，MYISAM不支持")])]),t._v(" "),e("h4",{attrs:{id:"注意"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意:")]),t._v(" "),e("p",[t._v("行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。")]),t._v(" "),e("h4",{attrs:{id:"操作-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作-2"}},[t._v("#")]),t._v(" 操作")]),t._v(" "),e("p",[t._v("参考读写锁的操作。")]),t._v(" "),e("h3",{attrs:{id:"元数据锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁"}},[t._v("#")]),t._v(" 元数据锁")]),t._v(" "),e("p",[t._v("元数据锁(meta data lock 简称MDL) 用于确保事务执行过程中表结构的稳定。")]),t._v(" "),e("h2",{attrs:{id:"间隙锁-gap-lock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁-gap-lock"}},[t._v("#")]),t._v(" 间隙锁(Gap Lock)")]),t._v(" "),e("ul",[e("li",[t._v("其他Session没法在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据(锁的操作都不能.)")]),t._v(" "),e("li",[t._v("锁的就是两个值之间的空隙，中访问到的对象才会加锁。")]),t._v(" "),e("li",[t._v("间隙锁是在可重复读隔离级别下才会生效。")]),t._v(" "),e("li",[t._v("左开右开区间")])]),t._v(" "),e("h2",{attrs:{id:"临键锁-next-key-locks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临键锁-next-key-locks"}},[t._v("#")]),t._v(" 临键锁(Next-key Locks)")]),t._v(" "),e("ul",[e("li",[t._v("行锁与间隙锁的组合")]),t._v(" "),e("li",[t._v("它的封锁范围，既包含索引记录，又包含索引区间。")]),t._v(" "),e("li",[t._v("可以解决幻读的问题。")]),t._v(" "),e("li",[t._v("在可重复读隔离级别下才会生效。")]),t._v(" "),e("li",[t._v("临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。")]),t._v(" "),e("li",[t._v("左开右闭区间")])]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结:")]),t._v(" "),e("p",[t._v("以下都是针对锁的前提下：")]),t._v(" "),e("p",[t._v("1、当使用唯一索引来等值查询的语句时, 如果这行数据存在，不产生间隙锁，而是记录锁。")]),t._v(" "),e("p",[t._v("2、当使用唯一索引来等值查询的语句时, 如果这行数据不存在，会产生间隙锁。")]),t._v(" "),e("p",[t._v("3、当使用唯一索引来范围查询的语句时，对于满足查询条件但不存在的数据产生间隙(gap)锁，如果查询存在的记录就会产生记录锁，加在一起就是临键锁(next-key)锁。")]),t._v(" "),e("p",[t._v("4、当使用普通索引不管是锁住单条，还是多条记录，都会产生间隙锁； 没有查询到没有影响。")]),t._v(" "),e("p",[t._v("5、在没有索引上不管是锁住单条，还是多条记录，还是没有查询到，都会产生"),e("strong",[t._v("表锁")]),t._v("；")]),t._v(" "),e("h1",{attrs:{id:"死锁问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#死锁问题"}},[t._v("#")]),t._v(" 死锁问题")]),t._v(" "),e("p",[t._v("当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。")]),t._v(" "),e("h2",{attrs:{id:"排查"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#排查"}},[t._v("#")]),t._v(" 排查")]),t._v(" "),e("ul",[e("li",[t._v("查看事务:: select * from INFORMATION_SCHEMA.INNODB_TRX;")]),t._v(" "),e("li",[t._v("查看锁 ::  select * from INFORMATION_SCHEMA.INNODB_LOCKS;")]),t._v(" "),e("li",[t._v("锁等待:: select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;")]),t._v(" "),e("li",[t._v("kill trx_mysql_thread_id")]),t._v(" "),e("li",[t._v("查看锁等待详细信息::: show engine innodb status\\G;")])]),t._v(" "),e("h2",{attrs:{id:"解决机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决机制"}},[t._v("#")]),t._v(" 解决机制")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("超时")]),t._v(" "),e("blockquote",[e("p",[t._v("直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。")])])]),t._v(" "),e("li",[e("p",[t._v("死锁主动检查")]),t._v(" "),e("blockquote",[e("p",[t._v("发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为on，表示开启死锁检测。")]),t._v(" "),e("p",[t._v("注意，死锁检查会消耗额外资源，若并发的线过多，则有可能由死锁检测而消耗过多资源而导数据库崩溃。")])])])]),t._v(" "),e("h1",{attrs:{id:"锁优化建议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁优化建议"}},[t._v("#")]),t._v(" 锁优化建议")]),t._v(" "),e("ul",[e("li",[t._v("尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁")]),t._v(" "),e("li",[t._v("合理设计索引，尽量缩小锁的范围")]),t._v(" "),e("li",[t._v("尽可能减少检索条件范围，避免间隙锁")]),t._v(" "),e("li",[t._v("尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行")]),t._v(" "),e("li",[t._v("尽可能低级别事务隔离")])]),t._v(" "),e("h1",{attrs:{id:"存储引擎中锁的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎中锁的区别"}},[t._v("#")]),t._v(" 存储引擎中锁的区别")]),t._v(" "),e("h2",{attrs:{id:"myisam"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#myisam"}},[t._v("#")]),t._v(" MyISAM")]),t._v(" "),e("p",[t._v("MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自 动给涉及的表加写锁。")]),t._v(" "),e("h2",{attrs:{id:"innodb"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#innodb"}},[t._v("#")]),t._v(" InnoDB")]),t._v(" "),e("p",[t._v("InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行 锁。")]),t._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7055111182755528741",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL锁的浅析到深入"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("共享锁，只锁覆盖索引的详细解释。")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/jelly12345/p/14491009.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("mysql记录锁（record lock）,间隙锁（gap lock）,Next-key锁（Next-key lock）"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_42360972/article/details/113464504",target:"_blank",rel:"noopener noreferrer"}},[t._v("mysql行锁升级为表锁_MySQL 全局锁、表锁以及行锁"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/477b7ccba3d2",target:"_blank",rel:"noopener noreferrer"}},[t._v("InnoDB行锁升级为表锁的问题"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/qq_44766883/article/details/105879308",target:"_blank",rel:"noopener noreferrer"}},[t._v("mysql的锁机制(读锁，写锁，表锁，行锁，悲观锁，乐观锁，间隙锁)"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1917462",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL记录锁、间隙锁、临键锁小案例演示"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6855129007336521741",target:"_blank",rel:"noopener noreferrer"}},[t._v("mysql事务和锁，一次性讲清楚！"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/qq_43277087/article/details/104687504",target:"_blank",rel:"noopener noreferrer"}},[t._v("什么时候数据库行锁会升级为表锁？"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("事务的隔离级别为："),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("可重复读"),e("OutboundLink")],1),t._v("时，如果有"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("索引"),e("OutboundLink")],1),t._v("（包括主键索引），以索引列为条件更新数据，会存在间隙锁，行锁，页锁，而锁住一些行。如果没有索引，更新数据时会"),e("strong",[t._v("锁住整张表")]),t._v("。")]),t._v(" "),e("p",[t._v("事务隔离级别为：串行化时，读写数据都会"),e("strong",[t._v("锁住整张表")]),t._v("。（一次只能一个连接玩表）")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/spring_model/article/details/53992450",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL间隙锁问题"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("insert  和 delete 同时操作一段间隙，就会导致一个等锁。")]),t._v(" "),e("p",[t._v("解决办法： 修改代码逻辑， 存在才删除，尽量不去删除不存在的记录。")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/huang007guo/article/details/115484612",target:"_blank",rel:"noopener noreferrer"}},[t._v("mysql排它锁(FOR UPDATE) 场景介绍"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("当前使用for "),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=UPDATE&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("UPDATE"),e("OutboundLink")],1),t._v("查询,其他地方查询  --  其他地方也使用for UPDATE会堵塞, 其他地方未使用for UPDATE不会堵塞")]),t._v(" "),e("li",[t._v("当前使用for UPDATE查询,其他地方UPDATE更新  --  "),e("strong",[t._v("会堵塞等待")])]),t._v(" "),e("li",[t._v("当前事务使用UPDATE更新, 其他地方使用for UPDATE查询  --  "),e("strong",[t._v("会堵塞等待")])]),t._v(" "),e("li",[t._v("当前非事务使用UPDATE更新, 其他地方使用for UPDATE查询  --  不会堵塞")]),t._v(" "),e("li",[t._v("当前普通查询,其他地方使用for UPDATE查询  --  不影响,不会堵塞")])]),t._v(" "),e("p",[t._v("总结: for UPDATE 和 update等操作 都是加锁的，select 是不加锁的，所以不会影响。")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/JohnABC/p/4381616.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL-乐观锁"),e("OutboundLink")],1),t._v("  和 "),e("a",{attrs:{href:"https://www.jianshu.com/p/5a081ff5de58",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL 技巧：如何实现乐观锁？"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("1.查询出商品信息")]),t._v(" "),e("p",[t._v("select (status,status,version) from t_goods where id=#{id}")]),t._v(" "),e("p",[t._v("2.根据商品信息生成订单")]),t._v(" "),e("p",[t._v("3.修改商品status为2")]),t._v(" "),e("p",[t._v("update t_goods")]),t._v(" "),e("p",[t._v("set status=2,version=version+1")]),t._v(" "),e("p",[t._v("where id=#{id} and version=#{version};")]),t._v(" "),e("p",[t._v("通过乐观锁+自旋的方式，解决数据更新的线程安全问题，而且锁粒度比悲观锁低，并发性能好。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);