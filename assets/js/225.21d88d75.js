(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{585:function(a,t,v){"use strict";v.r(t);var _=v(7),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"入门篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#入门篇"}},[a._v("#")]),a._v(" 入门篇")]),a._v(" "),t("h2",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),t("p",[a._v("数据结构： 就是一个能组在一起的集合对象。比如数组 链表 队列等。")]),a._v(" "),t("blockquote",[t("p",[a._v("线性表结构   ： 数组、链表、堆、栈\n非线性表结构 ： 树、图论\n算法：就是解决问题的")])]),a._v(" "),t("h2",{attrs:{id:"时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[a._v("#")]),a._v(" 时间复杂度")]),a._v(" "),t("p",[a._v("o(1）< o(log2n)<o(n)<o(nlog2n)<o(n^2)<o(n^3)<o(2^n)<o(n!)<o(n^n)")]),a._v(" "),t("ul",[t("li",[a._v("o(log2n) ： while( i <= n){  i = i * 2; }")]),a._v(" "),t("li",[a._v("O(n)  for(i = 0 ; i < n;i++){}")]),a._v(" "),t("li",[a._v("O(nlogn) ： for(int j = 0 ; j < n ;j++){   for(i = 0 ; i < n;i++){}   }")]),a._v(" "),t("li",[a._v("平方：O(n^2)  for(int j = 0 ; j < n ;j++){  for(int j = 0 ; j < n ;j++){} }")]),a._v(" "),t("li",[a._v("N次方：O(n^n)   O(n!) ：  n张牌的洗牌")])]),a._v(" "),t("h1",{attrs:{id:"基本数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本数据结构"}},[a._v("#")]),a._v(" 基本数据结构")]),a._v(" "),t("h2",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),t("p",[a._v("经典问题： 统计14亿年龄数据。 桶排序。\n特点： 连续的内存（CPU高速缓存），相同数据类型，随机访问O(1)的效率。\n为啥数组的下标要从0开始？ 申请的空间地址就是O(0)了，不需要1-1的额外操作。\n下标：数组最优一个特点。这里可以通过下标表示成有意义的数据，不只是数据里面的标记，年龄和下标对应。\n随机访问：可以直接通过下标定位到数组中的某一个数据 。  O(1) 复杂度。")]),a._v(" "),t("h2",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[a._v("#")]),a._v(" 链表")]),a._v(" "),t("h3",{attrs:{id:"经典问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#经典问题"}},[a._v("#")]),a._v(" 经典问题")]),a._v(" "),t("ul",[t("li",[a._v("LRU（最近最少使用）缓存淘汰算法？   找到删除，插入头节点，满了剔除尾节点。")]),a._v(" "),t("li",[a._v("约瑟夫问题？  环形链表，用size判断结束。")])]),a._v(" "),t("h3",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("p",[a._v("不需要连续的内存空间。\n有指针引用。\n有三种最常见的链表结构：单链表、双向链表和循环链表")]),a._v(" "),t("h3",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("插入/删除3种方式（头插法、尾插法、中间插法），实现各不相同。")]),a._v(" "),t("h3",{attrs:{id:"对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[a._v("#")]),a._v(" 对比")]),a._v(" "),t("p",[a._v("容易动态扩容； 稀疏数组，往往会用链表来代替。链表容易出现栈溢出。")]),a._v(" "),t("h2",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[a._v("#")]),a._v(" 栈")]),a._v(" "),t("h3",{attrs:{id:"经典问题-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#经典问题-2"}},[a._v("#")]),a._v(" 经典问题")]),a._v(" "),t("ul",[t("li",[a._v("如何设计一个括号匹配的功能 ： 1个栈，左边就入栈，右边出栈匹配")]),a._v(" "),t("li",[a._v("如何设计一个浏览器的前进和后退功能 ： 两个栈，点后退A出站到B入站。点前进从B出站到A入站。 点新页面,A栈清空B栈")]),a._v(" "),t("li",[a._v("代码函数调用中的应用。")]),a._v(" "),t("li",[a._v("数学表达式求值： 两个栈来实现：一个放数字 一个放符号。")])]),a._v(" "),t("blockquote",[t("p",[a._v("1.遇到是数字 我们就直接入栈到数字栈里面去。如果前一个也是数字，需要出栈*10 + 数字，再入栈。\n2.遇到是符合 就把符号栈的栈顶拿出来做比较。如果说他比栈顶符号的优先级高就直接入栈，如果比符号栈顶的优先级低或者相同，就从符号栈里面取栈顶进行计算（从数字栈中取栈顶的2个数），计算完的结果还要再放入到数字栈中。\n3.最后清空2个栈的内容。")])]),a._v(" "),t("h3",{attrs:{id:"特点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("p",[a._v("后进先出即Last In First Out （LIFO）\n栈顶入栈，栈顶出栈。\n出栈入栈都是O(1)的操作。 比较高效的数据结构。\n通常用于匹配的操作。")]),a._v(" "),t("h3",{attrs:{id:"实现-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-2"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("为啥不用数组和链表？？封装添加限制操作，防止误操作。\n通常以数组头为栈底，数组尾为栈顶的。\n通常以链表头为栈顶")]),a._v(" "),t("h2",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[a._v("#")]),a._v(" 队列")]),a._v(" "),t("p",[a._v("进行插入操作的端称为队尾，进行删除操作的端称为队头。\n想想排队，入队就是队尾插入，出队就是对头移除。\n先进先出（FIFO—first in first out）。")]),a._v(" "),t("h3",{attrs:{id:"应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),t("p",[a._v("优先队列： 普通用户，vip用户，svip用户。\n阻塞队列： 并发队列。\n队列在线程池中的应用")]),a._v(" "),t("h3",{attrs:{id:"操作分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作分类"}},[a._v("#")]),a._v(" 操作分类")]),a._v(" "),t("ul",[t("li",[a._v("单向队列（Queue）：只能在一段插入数据，另一端删除数据。")]),a._v(" "),t("li",[a._v("双向队列（Deque）：每一段都可以进行插入数据和删除数据的操作。")])]),a._v(" "),t("h3",{attrs:{id:"实现分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现分类"}},[a._v("#")]),a._v(" 实现分类")]),a._v(" "),t("p",[a._v("顺序队列,是基于数组实现的\n链式队列的实现\n循环队列,是一种顺序存储结构表示的队列，为了解决假溢出问题而将他设置成头尾相接的循环队列。")]),a._v(" "),t("blockquote",[t("p",[a._v("数据结构为 少用一个存储位置。取余的方式定位\n判断满：(tail+1)%n==head\n怎么判断空？tail==head\nsize的计算公式：   (tail - head + cap) % cap;")])]),a._v(" "),t("h1",{attrs:{id:"算法思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法思想"}},[a._v("#")]),a._v(" 算法思想")]),a._v(" "),t("h2",{attrs:{id:"思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思想"}},[a._v("#")]),a._v(" 思想")]),a._v(" "),t("h3",{attrs:{id:"枚举算法-暴力破解-枚举法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#枚举算法-暴力破解-枚举法"}},[a._v("#")]),a._v(" 枚举算法 | 暴力破解 | 枚举法")]),a._v(" "),t("p",[a._v("即对可能的解集合一一列举。  往往就是循环。\n（最基础的思想，能解决所有问题。唯一缺点就是慢，最最基础的解法）。")]),a._v(" "),t("h3",{attrs:{id:"数论算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数论算法"}},[a._v("#")]),a._v(" 数论算法")]),a._v(" "),t("p",[a._v("利用数学公式或者定理或者规律求解问题")]),a._v(" "),t("h3",{attrs:{id:"回溯算法-试探法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法-试探法"}},[a._v("#")]),a._v(" 回溯算法 | 试探法")]),a._v(" "),t("p",[a._v("和枚举类似，重点区别是试探不成功就不再继续了。")]),a._v(" "),t("h3",{attrs:{id:"分治算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分治算法"}},[a._v("#")]),a._v(" 分治算法")]),a._v(" "),t("p",[a._v("大问题分解成同类子问题，而后再合并。 （同时子问题之间没有公共的子问题：如f(n)=f(n-1)+f(n-2) ）。")]),a._v(" "),t("blockquote",[t("p",[a._v("不能合并 可以考虑贪心或者dp")])]),a._v(" "),t("h3",{attrs:{id:"贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[a._v("#")]),a._v(" 贪心算法")]),a._v(" "),t("h3",{attrs:{id:"动态规划-dp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划-dp"}},[a._v("#")]),a._v(" 动态规划 | dp")]),a._v(" "),t("h2",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[a._v("#")]),a._v(" 递归")]),a._v(" "),t("p",[a._v("常用的编码实现，属于手段。\n一般分2步:  递（分解） ， 归（合并）。\n常用的场景：大化小、求解思路"),t("strong",[a._v("完全")]),a._v("一样、终止条件。 3个条件满足\n编码注意 ： 求解公式、"),t("strong",[a._v("一定能执行的")]),a._v("终止条件")]),a._v(" "),t("p",[a._v("递归可以简化代码以及可读性高。\n但是使用起来一定要注意，栈溢出和时间问题。\n可以用循环优化它。")]),a._v(" "),t("h3",{attrs:{id:"应用-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用-2"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),t("ul",[t("li",[a._v("斐波那契数列 ： f(n)=f(n-1)+f(n-2)")]),a._v(" "),t("li",[a._v("微信分销系统中有一个返利。")]),a._v(" "),t("li",[a._v("n!，n的阶乘")])]),a._v(" "),t("h3",{attrs:{id:"递归的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归的优化"}},[a._v("#")]),a._v(" 递归的优化")]),a._v(" "),t("ul",[t("li",[a._v("使用非递归： 转化为循环，避免创建栈空间。")]),a._v(" "),t("li",[a._v("加入缓存 ： 避免重复计算。")]),a._v(" "),t("li",[a._v("尾递归 : 避免创建栈空间。 jdk源码里面大量使用。")])]),a._v(" "),t("blockquote",[t("p",[a._v("什么是尾递归？尾递归就是调用函数一定出现在末尾，没有任何其他的操作了(不会在做计算如 f(n-1)+1 )。\n避免创建栈空间: 因为我们编译器在编译代码时，如果发现函数末尾已经没有操作了，这时候就不会创建新的栈，而是覆盖到前面去。\n实现特点： 尾递归就是传入结果，倒着算，同时也不需要在回溯了。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);