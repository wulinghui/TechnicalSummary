(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{567:function(t,a,v){"use strict";v.r(a);var r=v(7),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"mvcc多版本并发控制机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvcc多版本并发控制机制"}},[t._v("#")]),t._v(" MVCC多版本并发控制机制")]),t._v(" "),a("ul",[a("li",[t._v("在读已提交和可重复读隔离级别下都实现了MVCC机制")]),t._v(" "),a("li",[t._v("对一行数据的读和写两个操作不通过加锁互斥来保证隔离性，避免了加锁互斥")]),t._v(" "),a("li",[a("code",[t._v("读-写")]),t._v(" 即一个事务进行读取操作，另一个进行写入操作。这种情况下可能会产生"),a("code",[t._v("脏读")]),t._v("、"),a("code",[t._v("不可重复读")]),t._v("、"),a("code",[t._v("幻读")]),t._v("。最好的方案是"),a("strong",[t._v("读操作利用多版本并发控制（"),a("code",[t._v("MVCC")]),t._v("），写操作进行加锁")]),t._v("。")]),t._v(" "),a("li",[t._v("总结:  MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取 同一条数据在版本链上的不同版本数据。")])]),t._v(" "),a("h1",{attrs:{id:"实现-机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现-机制"}},[t._v("#")]),t._v(" 实现/机制")]),t._v(" "),a("h2",{attrs:{id:"undo日志版本链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undo日志版本链"}},[t._v("#")]),t._v(" undo日志版本链")]),t._v(" "),a("ul",[a("li",[t._v("定义::  记录某个数据历次被修改的版本，并通过回滚指针连接起来，当发生数据回滚时可以通过undo版本链恢复到以前的数据。")]),t._v(" "),a("li",[t._v("据被多个事务依次修改过后，在每个事务修改完后，undo回滚日志会保留修改前的数据，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链")]),t._v(" "),a("li",[t._v("版本链状态 : 已提交的事务、未提交和已提交的事务、未开始的事务")])]),t._v(" "),a("h2",{attrs:{id:"read-view"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#read-view"}},[t._v("#")]),t._v(" read view")]),t._v(" "),a("p",[t._v("一致性视图，快照，也就是这个查询的数据副本。")]),t._v(" "),a("h3",{attrs:{id:"两部分组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两部分组成"}},[t._v("#")]),t._v(" 两部分组成")]),t._v(" "),a("ul",[a("li",[t._v("所有未提交事务id数组")]),t._v(" "),a("li",[t._v("已提交的最大事务id")])]),t._v(" "),a("h3",{attrs:{id:"生成时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成时机"}},[t._v("#")]),t._v(" 生成时机")]),t._v(" "),a("ul",[a("li",[t._v("在可重复读隔离级别，当事务开启，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化")]),t._v(" "),a("li",[t._v("如果是读已提交隔离级别在每次执行查询sql时都会重新生成")]),t._v(" "),a("li",[t._v("由以上两点区别，导致不同的隔离级别查询结果不一致！")])]),t._v(" "),a("h2",{attrs:{id:"undo版本链和read-view的对比规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undo版本链和read-view的对比规则"}},[t._v("#")]),t._v(" undo版本链和read-view的对比规则")]),t._v(" "),a("p",[t._v("undo版本链从上往下的循环，取事务id，和read-view进行对比")]),t._v(" "),a("h1",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_45076180/article/details/107730137",target:"_blank",rel:"noopener noreferrer"}},[t._v("mysql的MVCC机制详解"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);