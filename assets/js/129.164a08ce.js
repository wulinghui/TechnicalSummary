(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{489:function(a,t,r){"use strict";r.r(t);var s=r(7),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"设计同步器的意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计同步器的意义"}},[a._v("#")]),a._v(" 设计同步器的意义")]),a._v(" "),t("h2",{attrs:{id:"如何解决线程并发安全问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决线程并发安全问题"}},[a._v("#")]),a._v(" 如何解决线程并发安全问题？")]),a._v(" "),t("ul",[t("li",[a._v("序列化访问临界资源：：即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。")]),a._v(" "),t("li",[a._v("多线程共享，可变")])]),a._v(" "),t("h2",{attrs:{id:"多线程执行的过程是不可控的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程执行的过程是不可控的"}},[a._v("#")]),a._v(" 多线程执行的过程是不可控的？")]),a._v(" "),t("p",[a._v("所以需要采用同步机制来协同对对象可变状态的访问！")]),a._v(" "),t("h1",{attrs:{id:"synchronized的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的使用"}},[a._v("#")]),a._v(" synchronized的使用")]),a._v(" "),t("p",[a._v("synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内置锁，也叫作监视器锁。")]),a._v(" "),t("h2",{attrs:{id:"加锁方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加锁方式"}},[a._v("#")]),a._v(" 加锁方式")]),a._v(" "),t("p",[a._v("synchronized 实际是用对象锁保证了临界区内代码的原子性")]),a._v(" "),t("ul",[t("li",[a._v("实例方法")]),a._v(" "),t("li",[a._v("静态方法")]),a._v(" "),t("li",[a._v("代码块")])]),a._v(" "),t("h2",{attrs:{id:"sychronized的唤醒策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sychronized的唤醒策略"}},[a._v("#")]),a._v(" "),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/337477921",target:"_blank",rel:"noopener noreferrer"}},[a._v("sychronized的唤醒策略"),t("OutboundLink")],1)]),a._v(" "),t("blockquote",[t("ul",[t("li",[a._v("如果没有其它线程等锁，结束；")]),a._v(" "),t("li",[a._v("优先唤醒 EntryList 链表头部的线程；")]),a._v(" "),t("li",[a._v("如果 EntryList 是空的，把 cxq 链表赋值给 EntryList 链表，再唤醒 EntryList 头部的线程。")])]),a._v(" "),t("p",[a._v("而由于入队的时候 cxq 链表是头插的，所以 synchronized 默认的唤醒策略是，最后阻塞等锁的最先唤醒。")])]),a._v(" "),t("h1",{attrs:{id:"底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#底层原理"}},[a._v("#")]),a._v(" 底层原理")]),a._v(" "),t("p",[a._v("synchronized是JVM内置锁，基于"),t("strong",[a._v("Monitor")]),a._v("机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换（简称：上下文切换），对性能有较大影响。所以它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、自适应自旋（Adaptive Spinning）等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平有时更快。")]),a._v(" "),t("h2",{attrs:{id:"字节码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字节码"}},[a._v("#")]),a._v(" 字节码")]),a._v(" "),t("p",[a._v("Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和 MonitorExit指令来实现。")]),a._v(" "),t("h2",{attrs:{id:"monitor-管程-监视器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#monitor-管程-监视器"}},[a._v("#")]),a._v(" Monitor（管程/监视器）")]),a._v(" "),t("p",[a._v("Monitor，直译为“监视器”，而操作系统领域一般翻译为“管程”。管程是指管理共享变量以及对共享变量操作的过程，让它们支持并发。在Java 1.5之前，Java语言提供的唯一并发语言就是管程，Java 1.5之后提供的SDK并发包也是以管程为基础的。除了Java之外，C/C++、C#等高级语言也都是支持管程的。synchronized关键字和wait()、notify()、notifyAll()这三个方法是Java中实现管程技术的组成部分。")]),a._v(" "),t("h3",{attrs:{id:"什么是monitor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是monitor"}},[a._v("#")]),a._v(" 什么是monitor")]),a._v(" "),t("ul",[t("li",[a._v("一个同步工具、一种同步机制、描述为一个对象")]),a._v(" "),t("li",[a._v("每一个Java对象本身就带一把 看不见的锁，它叫做内部锁或者Monitor锁")]),a._v(" "),t("li",[a._v("Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式 获取锁的")])]),a._v(" "),t("h3",{attrs:{id:"monitor监视器锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#monitor监视器锁"}},[a._v("#")]),a._v(" Monitor监视器锁")]),a._v(" "),t("p",[a._v("Synchronized的语义底层是通过一个monitor的对象来 完成，其实wait/notify等方法也依赖于monitor对象。这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则 会抛出java.lang.IllegalMonitorStateException的异常的原因")]),a._v(" "),t("h2",{attrs:{id:"java内置管程synchronized"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内置管程synchronized"}},[a._v("#")]),a._v(" Java内置管程synchronized")]),a._v(" "),t("p",[a._v("Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。就是wait/notify/notifyAll。这样做简化了使用门槛。")]),a._v(" "),t("h2",{attrs:{id:"monitor机制在java中的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#monitor机制在java中的实现"}},[a._v("#")]),a._v(" "),t("a",{attrs:{href:"https://www.cnblogs.com/qingshan-tang/p/12698705.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Monitor机制在Java中的实现"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("具体得看jvm源码了。。这篇 https://www.cnblogs.com/qingshan-tang/p/12698705.html 博客写的还不错。")]),a._v(" "),t("h1",{attrs:{id:"wait-的正确使用姿势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wait-的正确使用姿势"}},[a._v("#")]),a._v(" wait()的正确使用姿势")]),a._v(" "),t("p",[a._v("对于MESA管程来说，有一个编程范式： 再wait方法中的demo就是这样写的.")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("     "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n     "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("         "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v("lt"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("condition does not hold"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v("gt"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n     "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("             obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("wait")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n     "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("         "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Perform action appropriate to condition")]),a._v("\n     "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("     "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[a._v("为什么要这样写呢?? 唤醒的时间和获取到锁继续执行的时间是不一致的，被唤醒的线程再次执行时可能条件又不满足了，所以循环检验条件。MESA模型的wait()方法还有一个超时参数，为了避免线程进入等待队列永久阻塞。")]),a._v(" "),t("h1",{attrs:{id:"notify-和notifyall-分别何时使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#notify-和notifyall-分别何时使用"}},[a._v("#")]),a._v(" notify()和notifyAll()分别何时使用")]),a._v(" "),t("p",[a._v("满足以下三个条件时，可以使用notify()，其余情况尽量使用notifyAll()：")]),a._v(" "),t("ol",[t("li",[a._v("所有等待线程拥有相同的等待条件；")]),a._v(" "),t("li",[a._v("所有等待线程被唤醒后，执行相同的操作；")]),a._v(" "),t("li",[a._v("只需要唤醒一个线程。")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("对象的内存布局")])]),a._v(" "),t("li",[t("ul",[t("li",[t("p",[a._v("对象头")])]),a._v(" "),t("li",[t("ul",[t("li",[t("p",[a._v("hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度等等")])]),a._v(" "),t("li",[t("p",[a._v("Java对象头一般占有2个机器码，如果对象是数组类型，则需要3个机器码")])]),a._v(" "),t("li",[t("p",[a._v("Mark Word")])]),a._v(" "),t("li",[t("ul",[t("li",[a._v("存储对象自身的运行时数据")]),a._v(" "),t("li",[a._v("Mark Word会随着程序的运行发生变化，以复用自己的存储空间")]),a._v(" "),t("li",[a._v("哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳")])])]),a._v(" "),t("li",[t("p",[a._v("哪些信息会被指针压缩")])]),a._v(" "),t("li",[t("ul",[t("li",[a._v("对象的全局静态变量(即类属性)")]),a._v(" "),t("li",[a._v("对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节")]),a._v(" "),t("li",[a._v("对象的引用类型：64位平台下，引用类型本身大小为8字节，压缩后为4字节")]),a._v(" "),t("li",[a._v("对象数组类型：64位平台下，数组类型本身大小为24字节，压缩后16字节")])])])])])])])]),a._v(" "),t("h1",{attrs:{id:"对象的内存布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局"}},[a._v("#")]),a._v(" 对象的内存布局")]),a._v(" "),t("h2",{attrs:{id:"对象头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象头"}},[a._v("#")]),a._v(" 对象头")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度")])]),a._v(" "),t("li",[t("p",[a._v("Java对象头一般占有2个机器码，如果对象是数组类型，则需要3个机器码")])])]),a._v(" "),t("h3",{attrs:{id:"mark-word"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mark-word"}},[a._v("#")]),a._v(" Mark Word")]),a._v(" "),t("ul",[t("li",[a._v("用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。")]),a._v(" "),t("li",[a._v("Mark Word会随着程序的运行发生变化，以复用自己的存储空间")])]),a._v(" "),t("h3",{attrs:{id:"klass-pointer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#klass-pointer"}},[a._v("#")]),a._v(" Klass Pointer")]),a._v(" "),t("p",[a._v("对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 32位4字节，64位开启指针压缩或最大堆内存<32g时4字节，否则8字节。jdk1.8默认开启指针压缩后为4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。")]),a._v(" "),t("p",[a._v("哪些信息会被指针压缩:")]),a._v(" "),t("ul",[t("li",[a._v("对象的全局静态变量(即类属性)")]),a._v(" "),t("li",[a._v("对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节")]),a._v(" "),t("li",[a._v("对象的引用类型：64位平台下，引用类型本身大小为8字节，压缩后为4字节")]),a._v(" "),t("li",[a._v("对象数组类型：64位平台下，数组类型本身大小为24字节，压缩后16字节")])]),a._v(" "),t("h3",{attrs:{id:"数组长度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组长度"}},[a._v("#")]),a._v(" 数组长度")]),a._v(" "),t("p",[a._v("如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度。 4字节")]),a._v(" "),t("h2",{attrs:{id:"实例数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例数据"}},[a._v("#")]),a._v(" 实例数据")]),a._v(" "),t("p",[a._v("存放类的属性数据信息，包括父类的属性信息；")]),a._v(" "),t("h2",{attrs:{id:"对齐填充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对齐填充"}},[a._v("#")]),a._v(" 对齐填充")]),a._v(" "),t("p",[a._v("由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐")]),a._v(" "),t("h2",{attrs:{id:"对象头分析工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象头分析工具"}},[a._v("#")]),a._v(" 对象头分析工具")]),a._v(" "),t("p",[a._v("运行时对象头锁状态分析工具JOL")]),a._v(" "),t("h1",{attrs:{id:"锁的膨胀升级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的膨胀升级"}},[a._v("#")]),a._v(" 锁的膨胀升级")]),a._v(" "),t("h2",{attrs:{id:"膨胀升级过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#膨胀升级过程"}},[a._v("#")]),a._v(" 膨胀升级过程")]),a._v(" "),t("ul",[t("li",[a._v("无锁状态、偏向锁、轻量级锁和重量级锁。只能从低到高升级，不会锁降级")]),a._v(" "),t("li",[a._v("JDK 1.6 中默认是开启偏向锁和轻量级锁的")])]),a._v(" "),t("h2",{attrs:{id:"无锁状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无锁状态"}},[a._v("#")]),a._v(" 无锁状态")]),a._v(" "),t("h2",{attrs:{id:"偏向锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁")]),a._v(" "),t("p",[a._v("线程获得了锁，那么锁就进入偏向模式，当同一线程再次请求锁时，无需再做任何同步操作，省去大量的锁申请操作，从而也就提高性能")]),a._v(" "),t("h3",{attrs:{id:"偏向锁延迟偏向"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁延迟偏向"}},[a._v("#")]),a._v(" 偏向锁延迟偏向")]),a._v(" "),t("p",[a._v("偏向锁模式存在偏向锁延迟机制：HotSpot 虚拟机在启动后有个 4s 的延迟才会对每个新建的对象开启偏向锁模式。JVM启动时会进行一系列的复杂活动，比如装载配置，系统类初始化等等。在这个过程中会使用大量synchronized关键字对对象加锁，且这些锁大多数都不是偏向锁。为了减少初始化时间，JVM默认延时加载偏向锁。")]),a._v(" "),t("h2",{attrs:{id:"轻量级锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[a._v("#")]),a._v(" 轻量级锁")]),a._v(" "),t("ul",[t("li",[a._v("转化时机:::修改偏向锁线程ID失败后，撤销偏向锁标识，改成轻量级锁的结构")]),a._v(" "),t("li",[a._v("应用场景:::: 对绝大部分的锁，在整个同步周期内都不存在竞争，也就是几个线程交替执行同步块的场合。")])]),a._v(" "),t("h2",{attrs:{id:"重量级锁-自旋锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁-自旋锁"}},[a._v("#")]),a._v(" 重量级锁(自旋锁)")]),a._v(" "),t("ul",[t("li",[a._v("适应性自旋")]),a._v(" "),t("li",[a._v("Mutex互斥量 (涉及上下文切换)")])]),a._v(" "),t("h2",{attrs:{id:"自旋优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自旋优化"}},[a._v("#")]),a._v(" 自旋优化")]),a._v(" "),t("p",[a._v("重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。")]),a._v(" "),t("ul",[t("li",[a._v("自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。")]),a._v(" "),t("li",[a._v("在 Java 6 之后自旋是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能。")]),a._v(" "),t("li",[a._v("Java 7 之后不能控制是否开启自旋功能")])]),a._v(" "),t("p",[a._v("注意：自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调用，存在用户态和内核态切换，这才是重量级锁最大的开销）")]),a._v(" "),t("h2",{attrs:{id:"锁粗化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁粗化"}},[a._v("#")]),a._v(" 锁粗化")]),a._v(" "),t("p",[a._v("假设一系列的连续操作都会对同一个对象反复加锁及解锁，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。\n比如:   每次调用 StringBuffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。")]),a._v(" "),t("h2",{attrs:{id:"锁消除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[a._v("#")]),a._v(" 锁消除")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("JIT编译时，去除不可能存在共享资源竞争的锁，节省毫无意义的请求锁时间")])]),a._v(" "),t("li",[t("p",[a._v("如: StringBuffer的append是一个同步方法，但是在add方法中StringBuffer属于一个局部变量,并且不会被其他线程所使用,JVM会自动将其锁消除")])]),a._v(" "),t("li",[t("p",[a._v("锁消除的依据是逃逸分析的数据支持")]),a._v(" "),t("blockquote",[t("ul",[t("li",[a._v("java必须运行在server模式 -server")]),a._v(" "),t("li",[a._v("同时必须开启逃逸分析 -XX:+DoEscapeAnalysis")]),a._v(" "),t("li",[a._v("开启锁消除 -XX:+EliminateLocks")])])])])]),a._v(" "),t("h3",{attrs:{id:"逃逸分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析"}},[a._v("#")]),a._v(" 逃逸分析")]),a._v(" "),t("p",[a._v("从jdk 1.7开始已经默认开启逃逸分析\n优化")]),a._v(" "),t("blockquote",[t("ul",[t("li",[a._v("同步省略")]),a._v(" "),t("li",[a._v("将堆分配转化为栈分配")]),a._v(" "),t("li",[a._v("分离对象或标量替换")])])]),a._v(" "),t("h2",{attrs:{id:"synchronized和lock的选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized和lock的选择"}},[a._v("#")]),a._v(" synchronized和lock的选择")]),a._v(" "),t("p",[a._v("参考 "),t("a",{attrs:{href:"https://www.jianshu.com/p/ee025b5f56d8",target:"_blank",rel:"noopener noreferrer"}},[a._v("[并发编程]synchronized与lock的性能比较"),t("OutboundLink")],1)]),a._v(" "),t("blockquote",[t("p",[a._v("性能：在高并发的情况下都是在一个数量集的，较高和较低并发下，synchronized都比Lock来的快，基本是两倍的关系。")]),a._v(" "),t("p",[a._v("我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化，可以考虑使用lock。")])]),a._v(" "),t("p",[a._v("这里和AQS原理相关:  LockSupport.park 也是操作系统的mutex和重量级锁一样了。\n所以低并发下，synchronized是偏向锁和轻量级锁。\n超高并发下:  AQS的cas空循环再")]),a._v(" "),t("h1",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/be8e4944374d",target:"_blank",rel:"noopener noreferrer"}},[a._v("Unsafe.park和Unsafe.unpark的底层实现原理"),t("OutboundLink")],1)]),a._v(" "),t("blockquote",[t("p",[a._v("https://cloud.tencent.com/developer/article/1460321\n在Linux系统下，是用的Posix线程库pthread中的mutex（互斥量），condition（条件变量）来实现的。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);