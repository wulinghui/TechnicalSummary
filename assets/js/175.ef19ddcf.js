(window.webpackJsonp=window.webpackJsonp||[]).push([[175],{535:function(a,e,t){"use strict";t.r(e);var r=t(7),s=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),e("p",[a._v("它是一个分布式协调框架，主要是用来解决分布式应用中经常遇到的一些数据管理问题。如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。也可以看做是一个用于存储少量数据的基于内存 的数据库")]),a._v(" "),e("h1",{attrs:{id:"核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[a._v("#")]),a._v(" 核心概念")]),a._v(" "),e("h2",{attrs:{id:"文件系统数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件系统数据结构"}},[a._v("#")]),a._v(" 文件系统数据结构")]),a._v(" "),e("h3",{attrs:{id:"持久化目录节点-persistent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持久化目录节点-persistent"}},[a._v("#")]),a._v(" 持久化目录节点 PERSISTENT")]),a._v(" "),e("p",[a._v("客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在")]),a._v(" "),e("h3",{attrs:{id:"持久化顺序编号目录节点-persistent-sequential"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持久化顺序编号目录节点-persistent-sequential"}},[a._v("#")]),a._v(" 持久化顺序编号目录节点 PERSISTENT_SEQUENTIAL")]),a._v(" "),e("p",[a._v("客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号")]),a._v(" "),e("h3",{attrs:{id:"临时目录节点ephemeral­"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临时目录节点ephemeral­"}},[a._v("#")]),a._v(" 临时目录节点EPHEMERAL­")]),a._v(" "),e("p",[a._v("客户端与zookeeper断开连接后，或者session超时，该节点被删除。")]),a._v(" "),e("p",[a._v("临时节点不能创建子节点。")]),a._v(" "),e("h3",{attrs:{id:"临时顺序编号目录节点ephemeral-sequential­"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临时顺序编号目录节点ephemeral-sequential­"}},[a._v("#")]),a._v(" 临时顺序编号目录节点EPHEMERAL_SEQUENTIAL­")]),a._v(" "),e("p",[a._v("客户端与zookeeper断开连接后，或者session超时，该节点被删除，只是Zookeeper给该节点名称进行顺序编号")]),a._v(" "),e("h3",{attrs:{id:"container"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#container"}},[a._v("#")]),a._v(" Container")]),a._v(" "),e("p",[a._v("如果Container节点下面没有子节点，则Container节点 在未来会被Zookeeper自动清除,定时任务默认60s 检查一次")]),a._v(" "),e("h3",{attrs:{id:"ttl-节点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ttl-节点"}},[a._v("#")]),a._v(" TTL 节点")]),a._v(" "),e("p",[a._v("过了TTL指定的时间，被服务器删除。默认禁用，只能通过系统配置 zookeeper.extendedTypesEnabled=true 开启，有bug不稳定")]),a._v(" "),e("h2",{attrs:{id:"监听通知机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#监听通知机制"}},[a._v("#")]),a._v(" 监听通知机制")]),a._v(" "),e("p",[a._v("客户端注册监听以下三种节点：")]),a._v(" "),e("ol",[e("li",[a._v("如果注册的是对某个"),e("strong",[a._v("节点")]),a._v("的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知")]),a._v(" "),e("li",[a._v("如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知")]),a._v(" "),e("li",[a._v("如果注册的是对某个"),e("strong",[a._v("目录的递归子节点")]),a._v("进行监听，则当这个目录下面的任意子节点有目录结构 的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。")])]),a._v(" "),e("p",[e("strong",[a._v("注意")]),a._v(" : 所有的通知都是一次性的")]),a._v(" "),e("h3",{attrs:{id:"事件类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件类型"}},[a._v("#")]),a._v(" 事件类型")]),a._v(" "),e("ul",[e("li",[a._v("None: 连接建立事件")]),a._v(" "),e("li",[a._v("NodeCreated： 节点创建")]),a._v(" "),e("li",[a._v("NodeDeleted： 节点删除")]),a._v(" "),e("li",[a._v("NodeDataChanged：节点数据变化")]),a._v(" "),e("li",[a._v("NodeChildrenChanged：子节点列表变化")]),a._v(" "),e("li",[a._v("DataWatchRemoved：节点监听被移除")]),a._v(" "),e("li",[a._v("ChildWatchRemoved：子节点监听被移除")])]),a._v(" "),e("h1",{attrs:{id:"命令行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令行"}},[a._v("#")]),a._v(" 命令行")]),a._v(" "),e("h2",{attrs:{id:"安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[a._v("#")]),a._v(" 安装")]),a._v(" "),e("ul",[e("li",[a._v("配置JAVA环境")]),a._v(" "),e("li",[a._v("下载解压 zookeeper")]),a._v(" "),e("li",[a._v("重命名配置文件 zoo_sample.cfg")]),a._v(" "),e("li",[a._v("启动zookeeper")])]),a._v(" "),e("h2",{attrs:{id:"命令行操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令行操作"}},[a._v("#")]),a._v(" 命令行操作")]),a._v(" "),e("h3",{attrs:{id:"创建zookeeper-节点命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建zookeeper-节点命令"}},[a._v("#")]),a._v(" 创建zookeeper 节点命令")]),a._v(" "),e("p",[a._v("create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]")]),a._v(" "),e("p",[a._v("-s: 顺序节点 -e: 临时节点 -c: 容器节点 -t: 可以给节点添加过期时间，默认禁用，需要通过系统参数启用 。没有则默认创建持久化节点")]),a._v(" "),e("p",[a._v("注意: 没有相对路径这么一说，所以，所 有的节点一定是以 / 开头")]),a._v(" "),e("h3",{attrs:{id:"查看节点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看节点"}},[a._v("#")]),a._v(" 查看节点")]),a._v(" "),e("p",[a._v("get [‐s] [‐w] path")]),a._v(" "),e("p",[a._v("-s 详细信息  -w 监听")]),a._v(" "),e("h3",{attrs:{id:"修改节点数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#修改节点数据"}},[a._v("#")]),a._v(" 修改节点数据")]),a._v(" "),e("p",[a._v("set [‐s] [‐v version] path data")]),a._v(" "),e("p",[a._v("-v 版本 ： 乐观锁控制并发，-1代表最新版本。")]),a._v(" "),e("h3",{attrs:{id:"查看节点状态信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看节点状态信息"}},[a._v("#")]),a._v(" 查看节点状态信息")]),a._v(" "),e("p",[a._v("stat [‐w] path")]),a._v(" "),e("ul",[e("li",[a._v("cZxid：创建znode的事务ID（Zxid的值）。")]),a._v(" "),e("li",[a._v("mZxid：最后修改znode的事务ID。")]),a._v(" "),e("li",[a._v("pZxid：最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）。")]),a._v(" "),e("li",[a._v("ctime：znode创建时间。")]),a._v(" "),e("li",[a._v("mtime：znode最近修改时间。")]),a._v(" "),e("li",[a._v("dataVersion：znode的当前数据版本。")]),a._v(" "),e("li",[a._v("cversion：znode的子节点结果集版本（一个节点的子节点增加、删除都会影响这个 版本）。")]),a._v(" "),e("li",[a._v("aclVersion：表示对此znode的acl版本。")]),a._v(" "),e("li",[a._v("ephemeralOwner：znode是临时znode时，表示znode所有者的 session ID。 如果 znode不是临时znode，则该字段设置为零。")]),a._v(" "),e("li",[a._v("dataLength：znode数据字段的长度。")]),a._v(" "),e("li",[a._v("numChildren：znode的子znode的数量。")])]),a._v(" "),e("h3",{attrs:{id:"查看子节点信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看子节点信息"}},[a._v("#")]),a._v(" 查看子节点信息")]),a._v(" "),e("p",[a._v("ls [‐s] [‐w] [‐R] path")]),a._v(" "),e("p",[a._v("-R 递归查看子节点列表")]),a._v(" "),e("h3",{attrs:{id:"事件监听机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件监听机制"}},[a._v("#")]),a._v(" 事件监听机制")]),a._v(" "),e("p",[a._v("get ‐w /path // 注册监听的同时获取数据")]),a._v(" "),e("p",[a._v("stat ‐w /path // 对节点进行监听，且获取元数据信息")]),a._v(" "),e("p",[a._v("ls ‐R ‐w /path // 针对递归子目录的监听")]),a._v(" "),e("h2",{attrs:{id:"acl-权限控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#acl-权限控制"}},[a._v("#")]),a._v(" ACL 权限控制")]),a._v(" "),e("p",[a._v("权限模式（Scheme）、授权对象（ID）、权限信息 （Permission）")]),a._v(" "),e("p",[a._v("getAcl 获取某个节点的acl权限信息")]),a._v(" "),e("p",[a._v("setAcl  设置某个节点的acl权限信息")]),a._v(" "),e("p",[a._v("addauth 输入认证授权信息")]),a._v(" "),e("h1",{attrs:{id:"内存数据和持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存数据和持久化"}},[a._v("#")]),a._v(" 内存数据和持久化")]),a._v(" "),e("p",[a._v("DataTree、DataNode")]),a._v(" "),e("h2",{attrs:{id:"事务日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务日志"}},[a._v("#")]),a._v(" 事务日志")]),a._v(" "),e("p",[a._v("针对每一次客户端的事务操作，也就是说对数据/权限的操作。")]),a._v(" "),e("p",[a._v("为了提升磁盘IO的效率， Zookeeper在创建事务日志文件的时候就进行文件空间的预分配- 即在创建文件的时候，就向操 作系统申请一块大一点的磁盘块。")]),a._v(" "),e("p",[a._v("事务日志文件名为： log.<当时最大事务ID>")]),a._v(" "),e("p",[a._v("内容有 ：")]),a._v(" "),e("p",[a._v("同时做了压缩(可以用org.apache.zookeeper.server.LogFormatter 格式化日志)")]),a._v(" "),e("p",[a._v("客户端会话ID，CXID,ZXID,操作类型，节点路径，节点数据，节点版本。")]),a._v(" "),e("h2",{attrs:{id:"数据快照"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据快照"}},[a._v("#")]),a._v(" 数据快照")]),a._v(" "),e("p",[a._v("数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。")]),a._v(" "),e("p",[a._v("快照事务日志文件名为： snapshot.<当时最大事务ID>")]),a._v(" "),e("p",[a._v("快照数据是反应当时内存数据的状态。事务日志是 更全面的数据，所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据 即可。 好多中间件都是这样实现的，如redis混合化持久性。")]),a._v(" "),e("h1",{attrs:{id:"java-客户端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-客户端"}},[a._v("#")]),a._v(" Java 客户端")]),a._v(" "),e("p",[a._v("zookeeper 官方的客户端没有和服务端代码分离，他们为同一个jar 文件。所以客户端的版本请保持与服务端版本一致。")]),a._v(" "),e("p",[a._v("new ZooKeeper（）的过程是异步的。需要用到CountDownLatch+回调做同步。")]),a._v(" "),e("p",[a._v("监听机制，可以再代码中用this传入做无限监听。")]),a._v(" "),e("h1",{attrs:{id:"curator-工具包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#curator-工具包"}},[a._v("#")]),a._v(" Curator 工具包")]),a._v(" "),e("p",[a._v("Curator 把我们平时常用的很多 ZooKeeper 服务开发功能做了封装，例如 客户端Leader 选举、 分布式计数器、分布式锁、会话重新连接、Watch 反复注册、多种异常处理、Cache 事件监听、分布式Barrier(栅栏)")]),a._v(" "),e("ul",[e("li",[a._v("pom包:   curator-framework简单的封装，curator-recipes高级功能特性")])]),a._v(" "),e("h2",{attrs:{id:"api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[a._v("#")]),a._v(" API")]),a._v(" "),e("ul",[e("li",[a._v("CuratorFramework#start() 方法代表启动。")]),a._v(" "),e("li",[a._v("CuratorFramework#getData() 获取数据")]),a._v(" "),e("li",[a._v("CuratorFramework#setData() 更新数据")]),a._v(" "),e("li",[a._v("CuratorFramework#delete() 删除节点")]),a._v(" "),e("li",[a._v("异步接口 : 默认使用EventThread线程池，可以自定义线程池。")]),a._v(" "),e("li",[a._v("监听器 ： CuratorListener类")])]),a._v(" "),e("h2",{attrs:{id:"protection模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#protection模式"}},[a._v("#")]),a._v(" protection模式")]),a._v(" "),e("p",[a._v("防止僵尸(幽灵)节点（由于异常原因导致出现下面的问题。）")]),a._v(" "),e("p",[a._v("Curator 的幂等性保证（再写成功以后返回时出错，同时再sessoin超时前恢复，那么会触发重试...就出现了重复数据）， "),e("code",[a._v("withProtection()")]),a._v(" 生成uuid，重试时再去查询这个客户端的uuid是否存在，来保证幂等性。")]),a._v(" "),e("h2",{attrs:{id:"caches"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#caches"}},[a._v("#")]),a._v(" Caches")]),a._v(" "),e("p",[a._v("Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，来实现反复注册的功能。")]),a._v(" "),e("p",[a._v("分为两类注册类型：节点监听和子节点监听。")]),a._v(" "),e("p",[a._v("Cache 事件监听可以理解为一 个本地缓存视图与远程 Zookeeper 视图的对比过程")]),a._v(" "),e("ul",[e("li",[a._v("node cache 对当前节点数据变化的处理")]),a._v(" "),e("li",[a._v("path cache  会对子节点进行监听，但是不会对二级子节点进行监听")]),a._v(" "),e("li",[a._v("tree cache  对当前节点的子节点，及递归子节点数据变化的处理")])]),a._v(" "),e("h1",{attrs:{id:"集群模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群模式"}},[a._v("#")]),a._v(" 集群模式")]),a._v(" "),e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),e("p",[e("strong",[a._v("Leader")]),a._v(":   处理所有的事务请求（写请求），可以处理读请求，集群中只能有一个Leader")]),a._v(" "),e("p",[e("strong",[a._v("Follower")]),a._v("：只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。")]),a._v(" "),e("p",[e("strong",[a._v("Observer")]),a._v("：只能处理读请求。不能参与选举")]),a._v(" "),e("p",[a._v("Follower/Observer :  接到写请求则转发到 Leader节点上。")]),a._v(" "),e("h2",{attrs:{id:"安装-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安装-2"}},[a._v("#")]),a._v(" 安装")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("前3步同单机安装。")])]),a._v(" "),e("li",[e("p",[a._v("修改配置文件zoo.cfg")])])]),a._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("dataDir")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/usr/local/data/zookeeper-1\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("clientPort")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2181")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# server.A=B：C：D：E  ")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 每个节点2个端口，其中一个为选举端口，一个为提供服务端口。")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# A 是一个数字，表示这个是第几号服务器；")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# B 是这个服务器的 ip 地址；")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端# 口；")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 如果需要通过添加不参与集群选举以及事务请求的过半机制的 Observer节点，可以在E的位置，添加observer标识。")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("server.1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:2001:3001:participant// participant 可以不用写，默认就是participant\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("server.2")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:2002:3002:participant\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("server.3")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:2003:3003:participant\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("server.4")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:2004:3004:observer \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br")])]),e("ul",[e("li",[a._v("标识myid文件的Server ID")])]),a._v(" "),e("p",[e("code",[a._v('echo "1">>myid')])]),a._v(" "),e("ul",[e("li",[a._v("启动实例")]),a._v(" "),e("li",[a._v("检测集群状态\n"),e("code",[a._v("zkServer.sh status conf/zoo1.cfg")])])]),a._v(" "),e("h2",{attrs:{id:"集群动态配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群动态配置"}},[a._v("#")]),a._v(" 集群动态配置")]),a._v(" "),e("p",[a._v("3.5.0 的新特性 ：")]),a._v(" "),e("ul",[e("li",[a._v("需要开启超级管理员身份验证模式 "),e("strong",[a._v("ACLs")])]),a._v(" "),e("li",[a._v("配置动态文件 :  dynamicConfigFile -> 指定动态配置文件的路径 ，reconfigEnabled  :  设置为true 开启动态配置")]),a._v(" "),e("li",[a._v("创建文件 zoo_replicated.cfg.dynamic")]),a._v(" "),e("li",[a._v("指令扩缩容")])]),a._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[a._v("reconfig "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-remove")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("  // 移除serverId为 "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" 的机器\nreconfig "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-add")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("server.3")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("**** // 把对应的机器加进来\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("ul",[e("li",[a._v("客户端可以通过监听 /zookeeper/confg 节点，来感知集群的变化。从而实现集群的动态变更")]),a._v(" "),e("li",[a._v("Curator 也自带了动态配置的监听，不需要额外的配置和代码实现监听更新；")])]),a._v(" "),e("h1",{attrs:{id:"应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),e("p",[a._v("所有的应用场景可以"),e("a",{attrs:{href:"https://curator.apache.org/curator-recipes/index.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("看curator的官网"),e("OutboundLink")],1)]),a._v(" "),e("h2",{attrs:{id:"分布式配置中心"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式配置中心"}},[a._v("#")]),a._v(" 分布式配置中心")]),a._v(" "),e("p",[a._v("Spring Cloud Zookeeper Config")]),a._v(" "),e("p",[a._v("原理 : 获得持久化节点数据、并且监听数据变更。")]),a._v(" "),e("h2",{attrs:{id:"分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[a._v("#")]),a._v(" 分布式锁")]),a._v(" "),e("h3",{attrs:{id:"非公平锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非公平锁"}},[a._v("#")]),a._v(" 非公平锁")]),a._v(" "),e("p",[a._v("通过 create -e /lock  ， get -w /lock ， delete /lock 简单实现。")]),a._v(" "),e("p",[a._v("羊群效应 ：所有的连接都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时收到事件，再次并发竞争。")]),a._v(" "),e("h3",{attrs:{id:"公平锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#公平锁"}},[a._v("#")]),a._v(" 公平锁")]),a._v(" "),e("p",[a._v("源码:")]),a._v(" "),e("ul",[e("li",[a._v("防止幽灵节点 ： protection模式")]),a._v(" "),e("li",[a._v("利用父容器节点的特性，减少父节点的数量。")]),a._v(" "),e("li",[a._v("避免羊群效应:  "),e("strong",[a._v("临时顺序节点，且只针对上个节点做监听")]),a._v("。")]),a._v(" "),e("li",[a._v("再客户端获得所有节点且排序，防止 ： 某个节点挂了导致顺序中断需要重建监听；网络IO获得的是无序的。")]),a._v(" "),e("li",[e("strong",[a._v("可重入锁")]),a._v("，再jvm本地有个atomicInt 来做的，防止了网络IO。")]),a._v(" "),e("li",[a._v("内部是使用的syncs / wait / notiyall 实现的等待唤醒机制。")]),a._v(" "),e("li",[a._v("一进来就先创建临时节点，之后再排序判断是不是最小的节点，再做监听等待唤醒机制。")])]),a._v(" "),e("p",[a._v("思考:")]),a._v(" "),e("ul",[e("li",[a._v("获得最小节点？？？ 获得所有节点，获得10位数字，并且排序（从网络中获得的列表返回值也是无序的，必须要的）就行了。")]),a._v(" "),e("li",[a._v("如果中间一个节点挂了，哪有怎么处理???   他后面那个节点监听到了之后，再去判断能不能获得锁，不能就继续排队组成新的监听链表。")]),a._v(" "),e("li",[a._v("防止幽灵节点 ： protection模式")]),a._v(" "),e("li",[a._v("为何用父容器节点 ？？？   减少父节点的数量。")]),a._v(" "),e("li",[a._v("临时顺序节点的目的 ???    直接创建并保证他的排序。")])]),a._v(" "),e("p",[a._v("非公平锁的羊群效应问题。 可以改进成AQS的第一次非公平，之后就排队的实现，也用公平锁的实现。")]),a._v(" "),e("h3",{attrs:{id:"共享锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#共享锁"}},[a._v("#")]),a._v(" 共享锁")]),a._v(" "),e("p",[a._v("读写锁的实现:  名称前缀为读写标识，用来判断获得锁成功与否。")]),a._v(" "),e("p",[a._v("细节：  读的监听上个写的，写的监听上个读或写的。 读读锁没有关联。")]),a._v(" "),e("h2",{attrs:{id:"分布式注册中心"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式注册中心"}},[a._v("#")]),a._v(" 分布式注册中心")]),a._v(" "),e("p",[a._v("spring cloud zookpeer")]),a._v(" "),e("p",[a._v("Rabbion动态更新ip注册表。")]),a._v(" "),e("p",[a._v("zookpeer 没有实现分片。")]),a._v(" "),e("p",[a._v("实现原理 :    临时节点 + 监听机制。")]),a._v(" "),e("h2",{attrs:{id:"集群选举"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群选举"}},[a._v("#")]),a._v(" "),e("a",{attrs:{href:"https://curator.apache.org/getting-started.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("集群选举"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("客户端领导选举，功能源码实现：")]),a._v(" "),e("p",[a._v("他会执行完回调代码后，再进行选举。")]),a._v(" "),e("p",[a._v("实现同一个周期时间只有一个人做事，同时每个人都有可能做事。")]),a._v(" "),e("p",[a._v("也是基于分布式的公平锁去实现的。")]),a._v(" "),e("h2",{attrs:{id:"发布-订阅"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅"}},[a._v("#")]),a._v(" 发布/订阅")]),a._v(" "),e("h2",{attrs:{id:"分布式队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式队列"}},[a._v("#")]),a._v(" 分布式队列")]),a._v(" "),e("h2",{attrs:{id:"分布式屏障"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式屏障"}},[a._v("#")]),a._v(" 分布式屏障")]),a._v(" "),e("h2",{attrs:{id:"计数器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计数器"}},[a._v("#")]),a._v(" 计数器")]),a._v(" "),e("h2",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[a._v("#")]),a._v(" 缓存")]),a._v(" "),e("h2",{attrs:{id:"节点-手表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节点-手表"}},[a._v("#")]),a._v(" 节点/手表")]),a._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1458839",target:"_blank",rel:"noopener noreferrer"}},[a._v("集群安装配置"),e("OutboundLink")],1)]),a._v(" "),e("blockquote",[e("p",[a._v("那2个端口可以随便配置。")])]),a._v(" "),e("p",[e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1863302",target:"_blank",rel:"noopener noreferrer"}},[a._v("Apache ZooKeeper - 使用ZK实现分布式锁(非公平锁/公平锁/共享锁 )"),e("OutboundLink")],1)]),a._v(" "),e("blockquote",[e("p",[a._v("非公平锁方案、羊群效应、公平锁方案、共享锁方案的原理。建议看看。")])]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7038596797446651940",target:"_blank",rel:"noopener noreferrer"}},[a._v("Zookeeper + Curator实现分布式锁"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb28cfdf418d42328ed43032a27d6490~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp",alt:""}})]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/6618471f6e75",target:"_blank",rel:"noopener noreferrer"}},[a._v("curator笔记-分布式锁的实现与原理"),e("OutboundLink")],1)]),a._v(" "),e("blockquote",[e("p",[a._v("详细的源码解析。")])]),a._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/CSDN_Stephen/article/details/78856323",target:"_blank",rel:"noopener noreferrer"}},[a._v("用Zookeeper作为Spring cloud的配置中心"),e("OutboundLink")],1)]),a._v(" "),e("blockquote",[e("p",[a._v("客户端使用 spring-cloud-starter-zookeeper-config")]),a._v(" "),e("p",[a._v("让客户端自动更新zookeeper变更的配置 ： 使用spring-boot-starter-actuator 模块，并开启watcher")])])])}),[],!1,null,null,null);e.default=s.exports}}]);